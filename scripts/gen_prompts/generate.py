"""Generate agent prompt files from config.yaml + Jinja2 templates.

ALWAYS run inside the maestro Docker container — never on the host:
    docker compose exec maestro python3 /app/scripts/gen_prompts/generate.py

Options:
    --check   Dry-run: print what would change without writing files.

Workflow:
    1. Edit scripts/gen_prompts/config.yaml  (or a template in templates/)
    2. docker compose exec maestro python3 /app/scripts/gen_prompts/generate.py
    3. Review the diff, then commit:
       git add .cursor/ scripts/gen_prompts/sync_labels.sh && git commit
    4. Run sync_labels.sh once to push label changes to GitHub:
       bash scripts/gen_prompts/sync_labels.sh
"""
from __future__ import annotations

import argparse
import os
import sys
from pathlib import Path

import yaml
from jinja2 import Environment, FileSystemLoader, StrictUndefined

SCRIPT_DIR = Path(__file__).parent
TEMPLATES_DIR = SCRIPT_DIR / "templates"

# Detect whether we're running inside Docker (/app) or on the host.
# The maestro container bind-mounts the repo root to /app; the generator
# must always be run inside that container so it writes to the live mount.
_APP_ROOT = Path("/app")
if _APP_ROOT.is_dir() and ((_APP_ROOT / "scripts").is_dir() or (_APP_ROOT / "maestro").is_dir()):
    REPO_ROOT = _APP_ROOT
else:
    # Fallback: two levels up from scripts/gen_prompts/ — only valid on host.
    REPO_ROOT = SCRIPT_DIR.parent.parent
    import warnings
    warnings.warn(
        "⚠️  generate.py is running OUTSIDE Docker. "
        "Prefer: docker compose exec maestro python3 /app/scripts/gen_prompts/generate.py",
        stacklevel=1,
    )

CURSOR_DIR = REPO_ROOT / ".cursor"
SYNC_LABELS_PATH = SCRIPT_DIR / "sync_labels.sh"

GENERATED_HEADER = (
    "<!-- Generated by scripts/gen_prompts/generate.py"
    " — edit the template, not this file. -->\n"
)


def _output_path(template_path: Path) -> Path:
    """Derive the .cursor/ output path from a template path.

    templates/roles/cto.md.j2         → .cursor/roles/cto.md
    templates/PARALLEL_PR_REVIEW.md.j2 → .cursor/PARALLEL_PR_REVIEW.md
    """
    rel = template_path.relative_to(TEMPLATES_DIR)
    output_rel = rel.with_suffix("") if rel.suffix == ".j2" else rel
    return CURSOR_DIR / output_rel


def _build_context(config: dict) -> dict:  # type: ignore[type-arg]
    """Flatten config.yaml into a Jinja2 render context."""
    repo = config["repo"]
    pipeline = config["pipeline"]
    codebases = config["codebases"]
    active_name: str = codebases["active"]
    active: dict = codebases[active_name]  # type: ignore[type-arg]

    phases: list[str] = pipeline["phases"]

    return {
        # Repo
        "gh_repo": repo["gh_slug"],
        "repo_name": repo["name"],

        # Pipeline
        "claim_label": pipeline["claim_label"],
        "max_pool_size": pipeline["max_pool_size"],
        "phases": phases,
        # Space-separated for shell for-loops, broken across lines for readability
        "phases_shell": _phases_shell(phases),
        # Prefix for the current active codebase labels
        "label_prefix": active["label_prefix"],

        # Active codebase
        "active_name": active_name,
        "active_container": active["container"],
        "active_mypy": active["mypy"],
        "active_test_dir": active["test_dir"],
        "active_test_glob": active["test_glob"],
        "active_label_prefix": active["label_prefix"],

        # All codebases (for reference in templates)
        "codebases": {k: v for k, v in codebases.items() if k != "active"},
    }


def _phases_shell(phases: list[str]) -> str:
    """Format phases as a shell word list for a for-loop, line-wrapped at 76 chars."""
    lines: list[str] = []
    current = "       for label in"
    indent = " " * 24
    for i, phase in enumerate(phases):
        token = f" {phase}"
        last = i == len(phases) - 1
        if len(current + token) > 76 and lines:
            lines.append(current + " \\")
            current = indent + phase
        elif current == "       for label in":
            current += token
        else:
            current += token
        if last:
            lines.append(current + "; do")
    return "\n".join(lines)


def _render(config: dict) -> dict[Path, str]:  # type: ignore[type-arg]
    """Render all templates, returning {output_path: rendered_content}."""
    env = Environment(
        loader=FileSystemLoader(str(TEMPLATES_DIR)),
        undefined=StrictUndefined,
        keep_trailing_newline=True,
        # Custom comment delimiters — default {# #} conflicts with shell
        # array-length syntax ${#ARRAY[@]} used throughout the prompt files.
        comment_start_string="{##",
        comment_end_string="##}",
    )
    context = _build_context(config)

    results: dict[Path, str] = {}
    for template_path in sorted(TEMPLATES_DIR.rglob("*.j2")):
        rel = str(template_path.relative_to(TEMPLATES_DIR))
        template = env.get_template(rel)
        rendered = GENERATED_HEADER + template.render(**context)
        rendered = rendered.rstrip("\n") + "\n"
        out = _output_path(template_path)
        results[out] = rendered

    return results


def _build_sync_labels_sh(config: dict) -> str:  # type: ignore[type-arg]
    """Generate sync_labels.sh — idempotent gh label create/edit script."""
    labels_cfg = config.get("labels", {})
    gh_repo = config["repo"]["gh_slug"]

    lines: list[str] = [
        "#!/usr/bin/env bash",
        "# sync_labels.sh — auto-generated by scripts/gen_prompts/generate.py",
        "# Run once after changing labels in config.yaml:",
        "#   bash scripts/gen_prompts/sync_labels.sh",
        "#",
        "# Requires: gh CLI authenticated with write access to the repo.",
        "# Safe to run repeatedly — uses `gh label edit` if the label already exists.",
        "set -euo pipefail",
        f'GH_REPO="{gh_repo}"',
        "",
        "# Helper: create label if absent, otherwise update color + description.",
        "sync_label() {",
        '  local name="$1" color="$2" desc="$3"',
        '  if gh label list --repo "$GH_REPO" --limit 200 | grep -q "^${name}\\b"; then',
        '    gh label edit "$name" --repo "$GH_REPO" --color "$color" --description "$desc"',
        '    echo "  ✏️  updated: $name"',
        "  else",
        '    gh label create "$name" --repo "$GH_REPO" --color "$color" --description "$desc"',
        '    echo "  ✅ created: $name"',
        "  fi",
        "}",
        "",
    ]

    # Claim label
    if "claim" in labels_cfg:
        cl = labels_cfg["claim"]
        lines.append("echo '── Claim label ──────────────────────────────────────────────'")
        lines.append(f"sync_label {_sh_quote(cl['name'])} {_sh_quote(cl['color'])} {_sh_quote(cl['description'])}")
        lines.append("")

    # Project label
    if "project" in labels_cfg:
        pl = labels_cfg["project"]
        lines.append("echo '── Project label ────────────────────────────────────────────'")
        lines.append(f"sync_label {_sh_quote(pl['name'])} {_sh_quote(pl['color'])} {_sh_quote(pl['description'])}")
        lines.append("")

    # Phase labels
    if "phases" in labels_cfg:
        lines.append("echo '── Phase labels ─────────────────────────────────────────────'")
        for label in labels_cfg["phases"]:
            lines.append(
                f"sync_label {_sh_quote(label['name'])} "
                f"{_sh_quote(label['color'])} "
                f"{_sh_quote(label['description'])}"
            )
        lines.append("")

    # Utility labels
    if "utility" in labels_cfg:
        lines.append("echo '── Utility labels ───────────────────────────────────────────'")
        for label in labels_cfg["utility"]:
            lines.append(
                f"sync_label {_sh_quote(label['name'])} "
                f"{_sh_quote(label['color'])} "
                f"{_sh_quote(label['description'])}"
            )
        lines.append("")

    lines.append("echo ''")
    lines.append("echo '✅ Label sync complete.'")
    return "\n".join(lines) + "\n"


def _sh_quote(s: str) -> str:
    """Single-quote a string for safe shell embedding."""
    return "'" + s.replace("'", "'\\''") + "'"


def main() -> None:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--check",
        action="store_true",
        help="Dry-run: show what would change without writing files.",
    )
    args = parser.parse_args()

    config_path = SCRIPT_DIR / "config.yaml"
    if not config_path.exists():
        print(f"❌ Config not found: {config_path}", file=sys.stderr)
        sys.exit(1)

    config = yaml.safe_load(config_path.read_text())
    results = _render(config)

    changed = 0
    for out_path, content in results.items():
        existing = out_path.read_text() if out_path.exists() else ""
        if existing == content:
            print(f"  (unchanged) {out_path.relative_to(REPO_ROOT)}")
            continue

        changed += 1
        if args.check:
            print(f"  WOULD UPDATE: {out_path.relative_to(REPO_ROOT)}")
        else:
            out_path.parent.mkdir(parents=True, exist_ok=True)
            out_path.write_text(content)
            print(f"  ✅ wrote {out_path.relative_to(REPO_ROOT)}")

    # Always regenerate sync_labels.sh (it's cheap and ensures it stays in sync)
    sync_content = _build_sync_labels_sh(config)
    sync_existing = SYNC_LABELS_PATH.read_text() if SYNC_LABELS_PATH.exists() else ""
    if sync_content != sync_existing:
        if not args.check:
            SYNC_LABELS_PATH.write_text(sync_content)
            SYNC_LABELS_PATH.chmod(0o755)
            print(f"  ✅ wrote scripts/gen_prompts/sync_labels.sh")
        else:
            print(f"  WOULD UPDATE: scripts/gen_prompts/sync_labels.sh")
        changed += 1
    else:
        print(f"  (unchanged) scripts/gen_prompts/sync_labels.sh")

    print()
    if args.check:
        print(f"{changed} file(s) would be updated.")
        if changed:
            sys.exit(1)
    else:
        print(f"{changed} file(s) updated.")


if __name__ == "__main__":
    main()
