"""MuseHub stress-test seed script.

Inserts a rich, realistic dataset that exercises every implemented URL,
every sidebar section, every social feature, every analytics panel, and
every discovery/explore surface.

Scale:
  - 8 users  (gabriel, sofia, marcus, yuki, aaliya, chen, fatou, pierre)
  - 12 repos across 5 genres
  - 30-50 commits per repo (with realistic branch history)
  - 10+ issues per repo, mix of open/closed
  - 4+ PRs per repo (open, merged, closed)
  - 2-4 releases per repo
  - 3-8 sessions per repo
  - Comments, reactions, follows, watches, notifications, forks, view events
  - Commit objects (tracks) with real instrument roles for the breakdown bar

Run inside the container:
  docker compose exec maestro python3 /app/scripts/seed_musehub.py

Idempotent: pass --force to wipe and re-insert.
"""
from __future__ import annotations

import asyncio
import hashlib
import sys
import uuid
from datetime import datetime, timedelta, timezone
from typing import Any

from sqlalchemy import text
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker

from maestro.config import settings
from maestro.db.musehub_models import (
    MusehubBranch,
    MusehubComment,
    MusehubCommit,
    MusehubDownloadEvent,
    MusehubFollow,
    MusehubFork,
    MusehubIssue,
    MusehubNotification,
    MusehubObject,
    MusehubProfile,
    MusehubPullRequest,
    MusehubReaction,
    MusehubRelease,
    MusehubRepo,
    MusehubSession,
    MusehubStar,
    MusehubViewEvent,
    MusehubWatch,
)


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

UTC = timezone.utc


def _now(days: int = 0, hours: int = 0) -> datetime:
    return datetime.now(tz=UTC) - timedelta(days=days, hours=hours)


def _sha(seed: str) -> str:
    return hashlib.sha256(seed.encode()).hexdigest()


def _uid(seed: str) -> str:
    return str(uuid.UUID(bytes=hashlib.md5(seed.encode()).digest()))


# ---------------------------------------------------------------------------
# Constants â€” stable IDs so URLs never change between re-seeds
# ---------------------------------------------------------------------------

# Users
GABRIEL  = "user-gabriel-001"
SOFIA    = "user-sofia-002"
MARCUS   = "user-marcus-003"
YUKI     = "user-yuki-004"
AALIYA   = "user-aaliya-005"
CHEN     = "user-chen-006"
FATOU    = "user-fatou-007"
PIERRE   = "user-pierre-008"

USERS = [
    (GABRIEL, "gabriel", "Composer & producer. Neo-soul, modal jazz, ambient. All sounds generated by Stori."),
    (SOFIA,   "sofia",   "Classical-meets-electronic. Algorithmic composition. Lover of Nils Frahm."),
    (MARCUS,  "marcus",  "Session keys player turned digital composer. Jazz, funk, everything in between."),
    (YUKI,    "yuki",    "Tokyo-based sound designer. Granular synthesis, algorithmic rhythms, and noise art."),
    (AALIYA,  "aaliya",  "Afrobeat, highlife, and jazz fusion. Lagos â†’ Berlin. Always in motion."),
    (CHEN,    "chen",    "Microtonal explorer. Just intonation, spectral music, extended techniques."),
    (FATOU,   "fatou",   "Griots meet Moog. West African rhythms with modular synthesis."),
    (PIERRE,  "pierre",  "French chanson meets minimalism. Piano, cello, and long silences."),
]

# Repos
REPO_NEO_SOUL     = "repo-neo-soul-00000001"
REPO_MODAL_JAZZ   = "repo-modal-jazz-000001"
REPO_AMBIENT      = "repo-ambient-textures-1"
REPO_AFROBEAT     = "repo-afrobeat-grooves-1"
REPO_MICROTONAL   = "repo-microtonal-etudes1"
REPO_DRUM_MACHINE = "repo-drum-machine-00001"
REPO_CHANSON      = "repo-chanson-minimale-1"
REPO_GRANULAR     = "repo-granular-studies-1"
REPO_FUNK_SUITE   = "repo-funk-suite-0000001"
REPO_JAZZ_TRIO    = "repo-jazz-trio-0000001"
REPO_NEO_SOUL_FORK = "repo-neo-soul-fork-0001"
REPO_AMBIENT_FORK  = "repo-ambient-fork-0001"

REPOS: list[dict[str, Any]] = [
    dict(repo_id=REPO_NEO_SOUL, name="Neo-Soul Experiment", owner="gabriel", slug="neo-soul-experiment",
         owner_user_id=GABRIEL, visibility="public",
         description="A funk-influenced neo-soul project exploring polyrhythmic grooves in F# minor.",
         tags=["neo-soul", "funk", "F# minor", "polyrhythm", "bass-heavy"],
         key_signature="F# minor", tempo_bpm=92, days_ago=90, star_count=24, fork_count=3),
    dict(repo_id=REPO_MODAL_JAZZ, name="Modal Jazz Sketches", owner="gabriel", slug="modal-jazz-sketches",
         owner_user_id=GABRIEL, visibility="public",
         description="Exploring Dorian and Phrygian modes. Miles Davis and Coltrane are the north stars.",
         tags=["jazz", "modal", "Dorian", "Phrygian", "piano", "trumpet"],
         key_signature="D Dorian", tempo_bpm=120, days_ago=60, star_count=18, fork_count=2),
    dict(repo_id=REPO_AMBIENT, name="Ambient Textures Vol. 1", owner="sofia", slug="ambient-textures-vol-1",
         owner_user_id=SOFIA, visibility="public",
         description="Slow-evolving pads and generative arpeggios. Inspired by Eno and Nils Frahm.",
         tags=["ambient", "generative", "pads", "Eb major", "slow"],
         key_signature="Eb major", tempo_bpm=60, days_ago=45, star_count=31, fork_count=5),
    dict(repo_id=REPO_AFROBEAT, name="Afrobeat Grooves", owner="aaliya", slug="afrobeat-grooves",
         owner_user_id=AALIYA, visibility="public",
         description="High-life meets contemporary production. Polyrhythmic percussion layers.",
         tags=["afrobeat", "highlife", "polyrhythm", "Lagos", "percussion"],
         key_signature="G major", tempo_bpm=128, days_ago=30, star_count=42, fork_count=6),
    dict(repo_id=REPO_MICROTONAL, name="Microtonal Ã‰tudes", owner="chen", slug="microtonal-etudes",
         owner_user_id=CHEN, visibility="public",
         description="31-TET explorations. Spectral harmony and just intonation studies.",
         tags=["microtonal", "spectral", "31-TET", "just intonation", "experimental"],
         key_signature="C (31-TET)", tempo_bpm=76, days_ago=25, star_count=9, fork_count=1),
    dict(repo_id=REPO_DRUM_MACHINE, name="808 Variations", owner="fatou", slug="808-variations",
         owner_user_id=FATOU, visibility="public",
         description="West African polyrhythm patterns through an 808 and modular synthesis.",
         tags=["drums", "808", "polyrhythm", "West Africa", "modular"],
         key_signature="A minor", tempo_bpm=100, days_ago=20, star_count=15, fork_count=2),
    dict(repo_id=REPO_CHANSON, name="Chanson Minimale", owner="pierre", slug="chanson-minimale",
         owner_user_id=PIERRE, visibility="public",
         description="French chanson miniatures. Piano and cello. Silence as a compositional element.",
         tags=["chanson", "minimalism", "piano", "cello", "French"],
         key_signature="A major", tempo_bpm=52, days_ago=15, star_count=7, fork_count=0),
    dict(repo_id=REPO_GRANULAR, name="Granular Studies", owner="yuki", slug="granular-studies",
         owner_user_id=YUKI, visibility="public",
         description="Granular synthesis research â€” texture, density, scatter. Source material: found sounds.",
         tags=["granular", "synthesis", "experimental", "Tokyo", "texture"],
         key_signature="E minor", tempo_bpm=70, days_ago=10, star_count=12, fork_count=1),
    dict(repo_id=REPO_FUNK_SUITE, name="Funk Suite No. 1", owner="marcus", slug="funk-suite-no-1",
         owner_user_id=MARCUS, visibility="public",
         description="A four-movement funk suite. Electric piano, clavinet, wah bass, and pocket drums.",
         tags=["funk", "electric piano", "clavinet", "groove", "suite"],
         key_signature="E minor", tempo_bpm=108, days_ago=50, star_count=28, fork_count=4),
    dict(repo_id=REPO_JAZZ_TRIO, name="Jazz Trio Sessions", owner="marcus", slug="jazz-trio-sessions",
         owner_user_id=MARCUS, visibility="public",
         description="Live-feel jazz trio recordings. Piano, double bass, brushed snare. Standards reimagined.",
         tags=["jazz", "trio", "piano", "bass", "standards"],
         key_signature="Bb major", tempo_bpm=138, days_ago=35, star_count=19, fork_count=2),
    # Forked repos (private â€” for the fork sidebar section)
    dict(repo_id=REPO_NEO_SOUL_FORK, name="Neo-Soul Experiment", owner="marcus", slug="neo-soul-experiment",
         owner_user_id=MARCUS, visibility="private",
         description="Fork of gabriel/neo-soul-experiment â€” Marcus's arrangement experiments.",
         tags=["neo-soul", "funk", "F# minor", "fork"],
         key_signature="F# minor", tempo_bpm=92, days_ago=10, star_count=0, fork_count=0),
    dict(repo_id=REPO_AMBIENT_FORK, name="Ambient Textures Vol. 1", owner="yuki", slug="ambient-textures-vol-1",
         owner_user_id=YUKI, visibility="private",
         description="Fork of sofia/ambient-textures-vol-1 â€” Yuki's granular re-imagining.",
         tags=["ambient", "granular", "fork"],
         key_signature="Eb major", tempo_bpm=60, days_ago=5, star_count=0, fork_count=0),
]


# ---------------------------------------------------------------------------
# Commit templates per repo
# ---------------------------------------------------------------------------

def _make_commits(repo_id: str, repo_key: str, n: int) -> list[dict[str, Any]]:
    """Generate n realistic commits for repo_key with a branching history."""
    TEMPLATES = {
        "neo-soul": [
            ("init: establish F# minor groove template at 92 BPM", "gabriel"),
            ("feat(bass): add polyrhythmic bass line â€” 3-against-4 pulse", "gabriel"),
            ("feat(keys): Rhodes chord voicings with upper-structure triads", "gabriel"),
            ("refactor(drums): humanize ghost notes, tighten hi-hat velocity", "gabriel"),
            ("feat(strings): bridge string section â€” section:bridge track:strings", "gabriel"),
            ("feat(horns): sketch trumpet + alto sax counter-melody", "gabriel"),
            ("fix(keys): resolve voice-leading parallel fifths in bar 7", "gabriel"),
            ("feat(guitar): add scratch guitar rhythm in chorus â€” track:guitar", "gabriel"),
            ("refactor(bass): tighten sub-bass at bar 13 to avoid muddiness", "marcus"),
            ("feat(perc): add shaker and tambourine for groove density", "gabriel"),
            ("fix(timing): realign hi-hat to quantize grid after humanize", "gabriel"),
            ("feat(choir): add background vocal pad â€” ooh/aah â€” section:chorus", "gabriel"),
            ("refactor(mix): reduce Rhodes level -3dB, open hi-hat +2dB", "marcus"),
            ("feat(bridge): call-and-response horn arrangement â€” bars 25-32", "gabriel"),
            ("fix(harmony): correct augmented chord spelling in turnaround", "gabriel"),
            ("feat(strings): counterpoint violin line against bass in verse", "gabriel"),
            ("refactor(drums): add kick variation in bar 4 of each 8-bar phrase", "marcus"),
            ("feat(organ): add organ swell in pre-chorus â€” track:organ", "gabriel"),
            ("fix(keys): remove accidental octave doubling in Rhodes voicing", "gabriel"),
            ("feat(bass): slap variation for funk breakdown â€” section:breakdown", "marcus"),
            ("refactor(horns): rewrite alto sax response phrase â€” cleaner contour", "gabriel"),
            ("feat(perc): cowbell accent on beat 3 of bar 2 â€” groove:funk", "gabriel"),
            ("feat(strings): pizzicato countermelody â€” bars 17-24", "gabriel"),
            ("fix(guitar): tighten wah envelope attack â€” reduce pre-delay", "gabriel"),
            ("feat(voice): lead vocal melody sketch â€” section:verse track:vocals", "gabriel"),
        ],
        "modal-jazz": [
            ("init: D Dorian vamp at 120 BPM â€” piano + bass", "gabriel"),
            ("feat(melody): Coltrane-inspired pentatonic runs over IV chord", "gabriel"),
            ("feat(drums): brush kit â€” swing factor 0.65", "gabriel"),
            ("experiment: Phrygian dominant bridge â€” E Phrygian Dominant", "gabriel"),
            ("feat(piano): add McCoy Tyner quartal voicings in A section", "gabriel"),
            ("fix(bass): correct walking bass note on bar 9 beat 3", "gabriel"),
            ("feat(trumpet): head melody sketch â€” 12-bar AABA form", "gabriel"),
            ("refactor(drums): increase ride cymbal bell accent frequency", "gabriel"),
            ("feat(piano): bebop left-hand comp pattern â€” bars 1-8", "marcus"),
            ("fix(melody): resolve blue note to major 3rd at phrase end", "gabriel"),
            ("feat(bass): pedal point through Phrygian section â€” E pedal", "gabriel"),
            ("feat(drums): hi-hat splash on beat 4 of turnaround", "gabriel"),
            ("refactor(piano): revoice III chord as tritone substitution", "gabriel"),
            ("feat(guitar): Freddie Green-style chord stabs â€” 4-to-the-bar", "marcus"),
            ("fix(trumpet): fix pitch of low C# â€” use Eb enharmonic", "gabriel"),
            ("feat(piano): out-chorus with McCoy quartal clusters", "gabriel"),
            ("feat(bass): counter-rhythm 2-bar fill after trumpet solo", "gabriel"),
        ],
        "ambient": [
            ("init: Eb major pad foundation â€” slow attack 4s release 8s", "sofia"),
            ("feat(arp): generative 16th-note arpeggiator â€” random seed 42", "sofia"),
            ("feat(texture): granular string texture layer â€” section:intro", "yuki"),
            ("fix(arp): reduce velocity variance â€” sounds too mechanical", "sofia"),
            ("feat(pad): add sub-octave layer for warmth â€” section:middle", "sofia"),
            ("feat(bells): wind chime texture â€” 7th partial harmonic series", "yuki"),
            ("refactor(arp): increase note-length randomization range", "sofia"),
            ("feat(drone): Eb pedal drone â€” bowed brass harmonic", "pierre"),
            ("fix(texture): reduce granular density in intro â€” too busy", "yuki"),
            ("feat(reverb): add convolution reverb impulse â€” Norwegian church", "sofia"),
            ("feat(pad): second pad layer â€” inversion of root chord", "sofia"),
            ("refactor(arp): change arpeggio direction â€” ascending + descending", "sofia"),
            ("feat(texture): filtered noise texture â€” high shelf +6dB", "yuki"),
            ("fix(drone): tune drone to equal temperament Eb", "sofia"),
            ("feat(melody): sparse piano melody â€” whole notes â€” section:climax", "pierre"),
            ("feat(fade): 3-minute fade out â€” linear to -80dB", "sofia"),
            ("refactor(mix): reduce string texture -2dB to sit behind pad", "yuki"),
            ("fix(arp): fix stuck note at bar 64 â€” midi note-off missing", "sofia"),
        ],
        "afrobeat": [
            ("init: G major groove at 128 BPM â€” 12/8 polyrhythm", "aaliya"),
            ("feat(perc): traditional talking drum pattern â€” track:tama", "aaliya"),
            ("feat(guitar): highlife guitar pattern â€” interlocking rhythm", "aaliya"),
            ("feat(bass): electric bass groove â€” root-fifth walking pattern", "aaliya"),
            ("feat(horns): brass unison figure â€” bars 1-4", "aaliya"),
            ("refactor(perc): tighten conga timing â€” reduce humanize variance", "fatou"),
            ("feat(keys): Fender Rhodes stabs â€” track:keys", "aaliya"),
            ("fix(guitar): fix choke on open string â€” add palm mute", "aaliya"),
            ("feat(choir): call-and-response vocal arrangement", "aaliya"),
            ("feat(bass): syncopated fills at section transitions", "aaliya"),
            ("refactor(horns): split alto and tenor lines â€” 3rd apart", "aaliya"),
            ("feat(perc): shekere layer â€” steady eighth-note pulse", "fatou"),
            ("fix(mix): reduce vocal level in verse â€” instrumental focus", "aaliya"),
            ("feat(guitar): second guitar â€” rhythmic scratches on offbeat", "aaliya"),
            ("feat(bass): slap bass hook for chorus energy boost", "aaliya"),
            ("refactor(drums): add more snare ghost notes â€” Questlove style", "fatou"),
            ("feat(keys): organ swell into chorus â€” track:organ", "aaliya"),
            ("fix(perc): fix timing drift on conga in bar 32", "fatou"),
            ("feat(strings): string overdub â€” Fela-inspired octave line", "aaliya"),
            ("feat(voice): lead vocal melody â€” Yoruba lyric sketch", "aaliya"),
        ],
        "microtonal": [
            ("init: C (31-TET) drone exploration at 76 BPM", "chen"),
            ("feat(harmony): otonal hexad â€” 4:5:6:7:9:11", "chen"),
            ("feat(melody): quarter-tone scale ascending line", "chen"),
            ("fix(tuning): correct 7th partial â€” was off by 3 cents", "chen"),
            ("feat(rhythm): Messiaen mode 3 rhythm grid", "chen"),
            ("feat(texture): spectral filtered noise â€” harmonic series", "chen"),
            ("refactor(melody): retrograde inversion of opening motif", "chen"),
            ("feat(bass): undertone series pedal â€” utonal foundation", "chen"),
            ("fix(harmony): resolve voice-leading microtonal step error", "chen"),
            ("feat(perc): non-retrogradable rhythm in timpani", "chen"),
            ("feat(strings): col legno battuto technique â€” quarter-tone gliss", "chen"),
            ("refactor(harmony): substitute Ptolemy's intense chromatic", "chen"),
            ("feat(woodwinds): multiphonics â€” clarinet + flute", "chen"),
            ("fix(tuning): recalibrate piano to equal 31-TET temperament", "chen"),
        ],
        "drums": [
            ("init: A minor 808 foundation at 100 BPM", "fatou"),
            ("feat(kick): four-on-the-floor with sub-frequency duck", "fatou"),
            ("feat(snare): syncopated snare with flam accent", "fatou"),
            ("feat(hihat): 16th-note hi-hat with velocity curve", "fatou"),
            ("feat(perc): djembe pattern â€” traditional Mandinka rhythm", "fatou"),
            ("feat(808): 808 bass note on root â€” 100ms decay", "fatou"),
            ("refactor(kick): tune 808 kick to key center A â€” 110Hz", "fatou"),
            ("fix(hihat): remove double-triggered hi-hat on beat 3", "fatou"),
            ("feat(perc): shaker accent pattern â€” offbeat sixteenths", "fatou"),
            ("feat(snare): ghost note velocity humanize â€” Â±12 velocity", "fatou"),
            ("feat(808): sub-bass movement â€” root to 5th fills", "fatou"),
            ("refactor(perc): layer djembe with finger drum machine", "fatou"),
            ("feat(crash): crash on bar 9 downbeat â€” section transition", "fatou"),
        ],
        "chanson": [
            ("init: A major sketch â€” piano solo motif at 52 BPM", "pierre"),
            ("feat(piano): left-hand ostinato â€” arpeggiated 9th chord", "pierre"),
            ("feat(cello): pizzicato bass line â€” bars 1-8", "pierre"),
            ("feat(piano): theme A â€” 8-bar melody in upper voice", "pierre"),
            ("feat(cello): sustained cello counterpoint â€” bars 9-16", "pierre"),
            ("refactor(piano): reduce left-hand density â€” let melody breathe", "pierre"),
            ("feat(piano): theme B in relative minor â€” F# minor", "pierre"),
            ("fix(cello): bowings â€” ensure smooth legato at bar 12", "pierre"),
            ("feat(piano): coda â€” augmented theme A in parallel 10ths", "pierre"),
            ("feat(silence): 4-bar rest before final chord â€” dynamic contrast", "pierre"),
            ("feat(cello): col legno tremolo â€” extended technique", "pierre"),
            ("refactor(harmony): substitute V7 with bVII for chanson flavour", "pierre"),
        ],
        "granular": [
            ("init: E minor granular pad â€” source: rain recording", "yuki"),
            ("feat(scatter): random scatter algorithm â€” grain size 20-80ms", "yuki"),
            ("feat(density): grain density envelope â€” sparse to dense", "yuki"),
            ("feat(pitch): pitch randomization Â±0.3 semitones", "yuki"),
            ("feat(texture): city ambience layer â€” Tokyo train station", "yuki"),
            ("fix(phase): fix grain phase correlation â€” reduce flamming", "yuki"),
            ("feat(filter): formant filter on granular output â€” vowel morph", "yuki"),
            ("refactor(scatter): increase random seed variation per bar", "yuki"),
            ("feat(rhythm): rhythmic granular â€” sync to 70 BPM sixteenths", "yuki"),
            ("fix(tuning): retune pitch center to E â€” was detuned +0.5st", "yuki"),
            ("feat(reverb): 8-second hall reverb tail â€” late reflections only", "yuki"),
            ("feat(mod): LFO modulation on grain position â€” 0.3Hz triangle", "yuki"),
        ],
        "funk-suite": [
            ("init: E minor funk groove at 108 BPM â€” Mvt. I", "marcus"),
            ("feat(bass): wah-wah bass hook â€” bars 1-4 â€” track:bass", "marcus"),
            ("feat(keys): electric piano chord voicings â€” tight stabs", "marcus"),
            ("feat(clavinet): clavinet riff â€” bars 5-8", "marcus"),
            ("feat(drums): pocket drum groove â€” ghost notes on snare", "marcus"),
            ("feat(guitar): rhythm guitar â€” interlocking with clavinet", "marcus"),
            ("feat(horns): brass hits on the upbeat â€” track:horns", "marcus"),
            ("refactor(bass): tighten wah envelope attack for more snap", "marcus"),
            ("feat(keys): Rhodes solo in Mvt. II â€” Dorian mode", "marcus"),
            ("fix(guitar): remove string buzz on open D", "marcus"),
            ("feat(bass): slap funk breakdown â€” Mvt. II outro", "marcus"),
            ("feat(perc): add congas â€” Afro-Cuban polyrhythm layer", "marcus"),
            ("feat(keys): B3 organ swell â€” Mvt. III transition", "marcus"),
            ("refactor(drums): accent hi-hat on the e's â€” open 16th feel", "marcus"),
            ("fix(horns): retune brass â€” flat by 8 cents on high notes", "marcus"),
            ("feat(bass): octave bass walk into chorus â€” track:bass", "marcus"),
            ("feat(clavinet): filtered clavinet â€” muted pickstyle", "marcus"),
            ("fix(keys): fix missed chord on beat 4 bar 22", "marcus"),
            ("feat(drums): Mvt. IV â€” double-time feel â€” hi-hat 16th groove", "marcus"),
            ("feat(bass): fretless bass for Mvt. IV â€” floating groove", "marcus"),
        ],
        "jazz-trio": [
            ("init: Bb major vamp â€” piano trio at 138 BPM", "marcus"),
            ("feat(piano): comping pattern â€” shell voicings 3-7", "marcus"),
            ("feat(bass): walking bass â€” Bb major standard changes", "marcus"),
            ("feat(drums): brushed snare pattern â€” triplet feel", "marcus"),
            ("feat(piano): solo chorus 1 â€” pentatonic approach", "marcus"),
            ("feat(bass): bass solo feature â€” rubato", "marcus"),
            ("feat(drums): trading 4s â€” kit break response", "marcus"),
            ("refactor(piano): reharmonize bridge â€” tritone subs", "marcus"),
            ("feat(piano): stride left hand in final chorus", "marcus"),
            ("fix(bass): fix intonation on F# â€” adjust finger placement", "marcus"),
            ("feat(drums): add brushed cymbal roll into solo sections", "marcus"),
            ("feat(piano): ballad tempo reduction for outro â€” â™©=72", "marcus"),
            ("refactor(bass): add counterpoint line during piano comping", "marcus"),
            ("fix(drums): remove extraneous kick note on bar 9", "marcus"),
            ("feat(piano): final cadenza â€” rubato", "marcus"),
        ],
    }

    key = repo_key
    templates = TEMPLATES.get(key, TEMPLATES["neo-soul"])
    commits: list[dict[str, Any]] = []
    prev_id: str | None = None
    branch = "main"
    t = templates * ((n // len(templates)) + 1)

    for i in range(n):
        cid = _sha(f"{repo_id}-commit-{i}")
        msg = t[i % len(templates)][0]
        author = t[i % len(templates)][1]
        days = (n - i) * 2  # older commits further back
        commits.append(dict(
            commit_id=cid,
            repo_id=repo_id,
            branch=branch,
            parent_ids=[prev_id] if prev_id else [],
            message=msg,
            author=author,
            timestamp=_now(days=days),
            snapshot_id=_sha(f"snap-{repo_id}-{i}"),
        ))
        prev_id = cid
        # Sprinkle in a feature branch every ~8 commits
        if i > 0 and i % 8 == 0:
            branch = "main"

    return commits


# Track roles per repo key for the instrument breakdown bar
REPO_TRACKS: dict[str, list[tuple[str, str]]] = {
    "neo-soul":     [("bass", "tracks/bass.mid"), ("keys", "tracks/rhodes.mid"),
                     ("drums", "tracks/drums.mid"), ("strings", "tracks/strings.mid"),
                     ("horns", "tracks/trumpet.mid"), ("horns", "tracks/alto_sax.mid"),
                     ("guitar", "tracks/guitar.mid"), ("vocals", "tracks/vocals.mid")],
    "modal-jazz":   [("piano", "tracks/piano.mid"), ("bass", "tracks/bass.mid"),
                     ("drums", "tracks/drums.mid"), ("trumpet", "tracks/trumpet.mid"),
                     ("guitar", "tracks/guitar.mid")],
    "ambient":      [("pad", "tracks/pad.mid"), ("arp", "tracks/arpeggiator.mid"),
                     ("strings", "tracks/strings.mid"), ("bells", "tracks/bells.mid"),
                     ("drone", "tracks/drone.mid")],
    "afrobeat":     [("perc", "tracks/talking_drum.mid"), ("guitar", "tracks/guitar.mid"),
                     ("bass", "tracks/bass.mid"), ("horns", "tracks/horns.mid"),
                     ("keys", "tracks/rhodes.mid"), ("perc", "tracks/shekere.mid"),
                     ("vocals", "tracks/vocals.mid")],
    "microtonal":   [("piano", "tracks/piano.mid"), ("strings", "tracks/strings.mid"),
                     ("woodwinds", "tracks/woodwinds.mid"), ("perc", "tracks/percussion.mid")],
    "drums":        [("kick", "tracks/kick.mid"), ("snare", "tracks/snare.mid"),
                     ("hihat", "tracks/hihat.mid"), ("perc", "tracks/djembe.mid"),
                     ("808", "tracks/808.mid")],
    "chanson":      [("piano", "tracks/piano.mid"), ("cello", "tracks/cello.mid")],
    "granular":     [("pad", "tracks/granular_pad.mid"), ("texture", "tracks/texture.mid"),
                     ("rhythm", "tracks/rhythmic.mid")],
    "funk-suite":   [("bass", "tracks/bass.mid"), ("keys", "tracks/electric_piano.mid"),
                     ("clavinet", "tracks/clavinet.mid"), ("drums", "tracks/drums.mid"),
                     ("guitar", "tracks/guitar.mid"), ("horns", "tracks/horns.mid"),
                     ("perc", "tracks/congas.mid")],
    "jazz-trio":    [("piano", "tracks/piano.mid"), ("bass", "tracks/bass.mid"),
                     ("drums", "tracks/drums.mid")],
}

REPO_KEY_MAP = {
    REPO_NEO_SOUL:     "neo-soul",
    REPO_MODAL_JAZZ:   "modal-jazz",
    REPO_AMBIENT:      "ambient",
    REPO_AFROBEAT:     "afrobeat",
    REPO_MICROTONAL:   "microtonal",
    REPO_DRUM_MACHINE: "drums",
    REPO_CHANSON:      "chanson",
    REPO_GRANULAR:     "granular",
    REPO_FUNK_SUITE:   "funk-suite",
    REPO_JAZZ_TRIO:    "jazz-trio",
    REPO_NEO_SOUL_FORK: "neo-soul",
    REPO_AMBIENT_FORK:  "ambient",
}

COMMIT_COUNTS = {
    REPO_NEO_SOUL:     40,
    REPO_MODAL_JAZZ:   30,
    REPO_AMBIENT:      35,
    REPO_AFROBEAT:     38,
    REPO_MICROTONAL:   25,
    REPO_DRUM_MACHINE: 28,
    REPO_CHANSON:      22,
    REPO_GRANULAR:     24,
    REPO_FUNK_SUITE:   42,
    REPO_JAZZ_TRIO:    32,
    REPO_NEO_SOUL_FORK: 8,
    REPO_AMBIENT_FORK:  5,
}

# ---------------------------------------------------------------------------
# Muse VCS â€” content-addressed MIDI objects, snapshots, commits, tags
# ---------------------------------------------------------------------------

# Track files per repo for Muse VCS â€” realistic MIDI instrument names and sizes.
# Piano solo: 8KBâ€“40KB; ensemble: 50KBâ€“200KB (task spec).
# Each tuple is (filename, base_size_bytes).
MUSE_VCS_FILES: dict[str, list[tuple[str, int]]] = {
    REPO_NEO_SOUL:     [("piano.mid", 24576),  ("bass.mid", 12288),   ("drums.mid", 16384),
                        ("violin.mid", 18432),  ("trumpet.mid", 13312)],
    REPO_FUNK_SUITE:   [("piano.mid", 22528),  ("bass.mid", 13312),   ("drums.mid", 16384),
                        ("trumpet.mid", 12288), ("flute.mid", 10240)],
    REPO_AFROBEAT:     [("bass.mid", 14336),   ("drums.mid", 18432),  ("violin.mid", 15360),
                        ("cello.mid", 14336),   ("trumpet.mid", 12288)],
    REPO_AMBIENT:      [("piano.mid", 32768),  ("violin.mid", 20480), ("cello.mid", 17408),
                        ("viola.mid", 15360),   ("flute.mid", 11264)],
    REPO_MODAL_JAZZ:   [("piano.mid", 28672),  ("bass.mid", 10240),   ("drums.mid", 14336),
                        ("trumpet.mid", 11264)],
    REPO_JAZZ_TRIO:    [("piano.mid", 26624),  ("bass.mid", 11264),   ("drums.mid", 13312)],
    REPO_MICROTONAL:   [("piano.mid", 20480),  ("violin.mid", 16384), ("cello.mid", 14336)],
    REPO_DRUM_MACHINE: [("drums.mid", 18432),  ("bass.mid", 12288)],
    REPO_CHANSON:      [("piano.mid", 36864),  ("cello.mid", 17408)],
    REPO_GRANULAR:     [("piano.mid", 15360),  ("violin.mid", 12288), ("flute.mid", 9216)],
    REPO_NEO_SOUL_FORK:[("piano.mid", 24576),  ("bass.mid", 12288),   ("drums.mid", 16384)],
    REPO_AMBIENT_FORK: [("piano.mid", 32768),  ("violin.mid", 20480), ("cello.mid", 17408)],
}

# Metadata per repo for muse_commits.metadata JSON field.
MUSE_COMMIT_META: dict[str, dict[str, object]] = {
    REPO_NEO_SOUL:     {"tempo_bpm": 92.0,  "key": "F# minor", "time_signature": "4/4", "instrument_count": 5},
    REPO_FUNK_SUITE:   {"tempo_bpm": 108.0, "key": "E minor",  "time_signature": "4/4", "instrument_count": 5},
    REPO_AFROBEAT:     {"tempo_bpm": 128.0, "key": "G major",  "time_signature": "12/8","instrument_count": 5},
    REPO_AMBIENT:      {"tempo_bpm": 60.0,  "key": "Eb major", "time_signature": "4/4", "instrument_count": 5},
    REPO_MODAL_JAZZ:   {"tempo_bpm": 120.0, "key": "D Dorian", "time_signature": "4/4", "instrument_count": 4},
    REPO_JAZZ_TRIO:    {"tempo_bpm": 138.0, "key": "Bb major", "time_signature": "3/4", "instrument_count": 3},
    REPO_MICROTONAL:   {"tempo_bpm": 76.0,  "key": "C (31-TET)","time_signature":"4/4", "instrument_count": 3},
    REPO_DRUM_MACHINE: {"tempo_bpm": 100.0, "key": "A minor",  "time_signature": "4/4", "instrument_count": 2},
    REPO_CHANSON:      {"tempo_bpm": 52.0,  "key": "A major",  "time_signature": "4/4", "instrument_count": 2},
    REPO_GRANULAR:     {"tempo_bpm": 70.0,  "key": "E minor",  "time_signature": "4/4", "instrument_count": 3},
    REPO_NEO_SOUL_FORK:{"tempo_bpm": 92.0,  "key": "F# minor", "time_signature": "4/4", "instrument_count": 3},
    REPO_AMBIENT_FORK: {"tempo_bpm": 60.0,  "key": "Eb major", "time_signature": "4/4", "instrument_count": 3},
}

# Muse tag taxonomy â€” ALL values from the task spec must appear in the seed.
MUSE_EMOTION_TAGS = [
    "melancholic", "joyful", "tense", "serene", "triumphant",
    "mysterious", "playful", "tender", "energetic", "complex",
]
MUSE_STAGE_TAGS = [
    "sketch", "rough-mix", "arrangement", "production", "mixing", "mastering", "released",
]
MUSE_KEY_TAGS = [
    "C", "Am", "G", "Em", "Bb", "F#", "Db", "Abm", "D", "Bm", "A", "F", "Eb", "Cm",
]
MUSE_TEMPO_TAGS = [
    "60bpm", "72bpm", "80bpm", "96bpm", "120bpm", "132bpm", "140bpm", "160bpm",
]
MUSE_GENRE_TAGS = [
    "baroque", "romantic", "ragtime", "edm", "ambient", "cinematic",
    "jazz", "afrobeats", "classical", "fusion",
]
MUSE_REF_TAGS = [
    "bach", "chopin", "debussy", "coltrane", "daft-punk", "beethoven", "joplin", "monk",
]

# Full flat list of all taxonomy tags â€” used when cycling through commits.
_ALL_MUSE_TAGS: list[str] = (
    MUSE_EMOTION_TAGS
    + MUSE_STAGE_TAGS
    + MUSE_KEY_TAGS
    + MUSE_TEMPO_TAGS
    + MUSE_GENRE_TAGS
    + MUSE_REF_TAGS
)

# Repos that get the full rich tag taxonomy (most active, richest history).
MUSE_RICH_TAG_REPOS = {REPO_NEO_SOUL, REPO_FUNK_SUITE}


# ---------------------------------------------------------------------------
# Issue templates
# ---------------------------------------------------------------------------

ISSUE_TEMPLATES: dict[str, list[dict[str, Any]]] = {
    "neo-soul": [
        dict(n=1, state="open",   title="Bass line loses tension in bar 9",
             body="3-against-4 pulse drifts. Ghost note on beat 2.5 recommended.", labels=["groove", "bass"]),
        dict(n=2, state="open",   title="Add guitar scratch rhythm track",
             body="Arrangement too sparse. Scratch guitar would complement Rhodes.", labels=["arrangement"]),
        dict(n=3, state="closed", title="Tempo fluctuates bars 4-8",
             body="Resolved by re-quantizing with tight humanization.", labels=["tempo", "drums"]),
        dict(n=4, state="open",   title="Choir voicing too wide in chorus",
             body="Soprano and bass parts are 2+ octaves apart â€” muddy on small speakers.", labels=["harmony"]),
        dict(n=5, state="open",   title="Organ swell clashes with Rhodes",
             body="Both sit in mid-range 400-800Hz. Pan or EQ to separate.", labels=["mix"]),
        dict(n=6, state="closed", title="String pizzicato timing off",
             body="Fixed â€” re-quantized to 16th grid with 10ms humanize.", labels=["strings", "timing"]),
        dict(n=7, state="open",   title="Bridge needs more harmonic tension",
             body="The IV-I cadence in the bridge is too resolved. Try IV-bVII.", labels=["harmony", "bridge"]),
        dict(n=8, state="open",   title="Trumpet counter-melody too high",
             body="Goes above high C. Alto sax range would be more idiomatic.", labels=["horns"]),
        dict(n=9, state="closed", title="Bass note collision on beat 1",
             body="Fixed â€” root changed from F# to C# (5th) to reduce mud.", labels=["bass", "harmony"]),
        dict(n=10, state="open",  title="Add breakdown section before final chorus",
             body="Energy needs to drop before the big finish. 4-bar bass+drums only.", labels=["arrangement"]),
        dict(n=11, state="open",  title="Vocals too bright â€” needs de-essing",
             body="Sibilance prominent on headphones. High shelf cut above 10kHz.", labels=["mix", "vocals"]),
        dict(n=12, state="open",  title="Consider key change to A minor for outro",
             body="A modulation to relative major would give a brighter feel at the end.", labels=["harmony"]),
    ],
    "modal-jazz": [
        dict(n=1, state="open",   title="Phrygian bridge needs ii-V turnaround",
             body="Jump from D Dorian to E Phrygian is abrupt. Add Am7b5 â†’ D7alt.", labels=["harmony"]),
        dict(n=2, state="open",   title="Swing factor inconsistent piano vs bass",
             body="Piano at 0.65 swing, bass at 0.55. Should match.", labels=["groove", "timing"]),
        dict(n=3, state="closed", title="Piano pedaling too heavy in changes",
             body="Fixed â€” reduced sustain pedal range.", labels=["piano"]),
        dict(n=4, state="open",   title="Guitar chord stabs too loud",
             body="Freddie Green stabs should sit under the piano. Lower -3dB.", labels=["mix", "guitar"]),
        dict(n=5, state="open",   title="Head melody needs resolution note",
             body="The A section ends on 6th scale degree â€” unresolved. Add scale degree 1.", labels=["melody"]),
        dict(n=6, state="open",   title="Tritone sub reharmonization too frequent",
             body="Using sub every 2 bars sounds formulaic. Reserve for 8-bar phrase end.", labels=["harmony"]),
        dict(n=7, state="closed", title="Bass solo too long â€” loses listener",
             body="Trimmed to 16 bars. Better pacing.", labels=["bass"]),
        dict(n=8, state="open",   title="Drummer needs to lay back on trumpet solo",
             body="Ride accent too prominent during solo. Comp more sparsely.", labels=["drums"]),
    ],
    "ambient": [
        dict(n=1, state="open",   title="Arpeggiator repeats â€” needs more variation",
             body="After 32 bars the pattern becomes predictable. Modulate seed every 8 bars.", labels=["generative"]),
        dict(n=2, state="open",   title="Pad too washy â€” needs more definition",
             body="Attack of 4s is too slow. Try 2s with a short sustain plateau.", labels=["pad"]),
        dict(n=3, state="closed", title="Stuck note in arp at bar 64",
             body="Fixed â€” MIDI note-off added. Was a gate issue.", labels=["bug", "midi"]),
        dict(n=4, state="open",   title="Add harmonic movement after bar 48",
             body="The Eb pedal has been static for 3 minutes. Move to Ab for 8 bars.", labels=["harmony"]),
        dict(n=5, state="open",   title="Norwegian church reverb is too bright",
             body="High frequency content in reverb tail is distracting. EQ pre-send.", labels=["mix"]),
        dict(n=6, state="open",   title="Granular density too high in intro",
             body="Start sparser and build. Currently too dense from bar 1.", labels=["texture"]),
        dict(n=7, state="closed", title="Phase correlation issues in stereo pad",
             body="Resolved by setting stereo width to 80% (was 120%).", labels=["mix"]),
        dict(n=8, state="open",   title="Piano melody needs more dynamic variation",
             body="All notes at same velocity. Add cresc/dim on each 4-bar phrase.", labels=["piano", "dynamics"]),
        dict(n=9, state="open",   title="Wind chimes pitched too high",
             body="7th partial sits above 8kHz on most speakers. Lower source pitch.", labels=["texture"]),
    ],
    "afrobeat": [
        dict(n=1, state="open",   title="Talking drum pattern needs more swing",
             body="Djembe is perfectly quantized â€” needs human timing Â±5ms.", labels=["groove", "perc"]),
        dict(n=2, state="open",   title="Highlife guitar pattern clash with bass",
             body="Both emphasise beat 1. Guitar should accent beats 2 and 4.", labels=["arrangement"]),
        dict(n=3, state="closed", title="Conga timing drift at bar 32",
             body="Fixed â€” re-quantized to 8th note grid.", labels=["perc", "timing"]),
        dict(n=4, state="open",   title="Brass unison too thick â€” needs harmony",
             body="Four instruments in unison is thin. Split into 3-part harmony.", labels=["horns"]),
        dict(n=5, state="open",   title="Vocal call-and-response timing off",
             body="Response phrases enter 1 beat early. Needs 4-beat gap.", labels=["vocals"]),
        dict(n=6, state="open",   title="Add agogo bell pattern",
             body="The timeline/bell pattern is missing. Essential for afrobeat structure.", labels=["perc"]),
        dict(n=7, state="open",   title="Bass slap too clicky at high velocity",
             body="Velocities above 100 produce unwanted transient click.", labels=["bass"]),
        dict(n=8, state="closed", title="Organ swell level too high",
             body="Reduced by -4dB. Now sits correctly behind guitar.", labels=["mix"]),
        dict(n=9, state="open",   title="Yoruba lyric timing â€” stress on wrong syllable",
             body="Need input from native speaker on placement of tonal accent.", labels=["vocals", "cultural"]),
        dict(n=10, state="open",  title="Add Talking Heads-style guitar texture",
             body="Open-string plucked guitar arpeggio on top of the rhythm section.", labels=["guitar"]),
    ],
}

# Use a generic template for repos without specific issues
GENERIC_ISSUES = [
    dict(n=1, state="open",   title="Energy drops in the middle section",
         body="The arrangement loses momentum around bar 24-32. Add element to sustain interest.",
         labels=["arrangement", "energy"]),
    dict(n=2, state="open",   title="Dynamics too compressed",
         body="The quietest and loudest moments are within 3dB. Needs more dynamic range.",
         labels=["mix", "dynamics"]),
    dict(n=3, state="closed", title="Tempo inconsistency between sections",
         body="Fixed by applying strict quantize to all MIDI.", labels=["timing"]),
    dict(n=4, state="open",   title="Add a counter-melody",
         body="The main melody is unaccompanied for too long. Add a secondary voice.",
         labels=["arrangement"]),
    dict(n=5, state="open",   title="Harmonic rhythm too fast in verse",
         body="Chord changes every 2 beats feels rushed. Try 4-beat chord duration.",
         labels=["harmony"]),
    dict(n=6, state="closed", title="Mix: low end muddy",
         body="Resolved â€” high-pass filter below 80Hz on all non-bass instruments.",
         labels=["mix"]),
]


# ---------------------------------------------------------------------------
# PR templates
# ---------------------------------------------------------------------------

def _make_prs(repo_id: str, commits: list[dict[str, Any]], owner: str) -> list[dict[str, Any]]:
    """Generate 4 template pull requests (open, merged, open, closed) for a repo."""
    if len(commits) < 4:
        return []
    c = commits
    return [
        dict(pr_id=_uid(f"pr-{repo_id}-1"), repo_id=repo_id,
             title="Feat: add counter-melody layer",
             body="## Changes\nAdds secondary melodic voice.\n\n## Analysis\nHarmonic tension +0.08.",
             state="open", from_branch="feat/counter-melody", to_branch="main",
             author=owner,
             created_at=_now(days=6)),
        dict(pr_id=_uid(f"pr-{repo_id}-2"), repo_id=repo_id,
             title="Refactor: humanize all MIDI timing",
             body="Applied `muse humanize --natural` to all tracks. Groove score +0.12.",
             state="merged", from_branch="fix/humanize-midi", to_branch="main",
             merge_commit_id=c[-3]["commit_id"],
             author=owner,
             created_at=_now(days=14)),
        dict(pr_id=_uid(f"pr-{repo_id}-3"), repo_id=repo_id,
             title="Experiment: alternate bridge harmony",
             body="Trying a tritone substitution approach for the bridge section.",
             state="open", from_branch="experiment/bridge-harmony", to_branch="main",
             author=owner,
             created_at=_now(days=3)),
        dict(pr_id=_uid(f"pr-{repo_id}-4"), repo_id=repo_id,
             title="Fix: resolve voice-leading errors",
             body="Parallel 5ths in bars 7-8 and parallel octaves in bars 15-16 corrected.",
             state="closed", from_branch="fix/voice-leading", to_branch="main",
             author=owner,
             created_at=_now(days=20)),
    ]


# ---------------------------------------------------------------------------
# Release templates
# ---------------------------------------------------------------------------

def _make_releases(repo_id: str, commits: list[dict[str, Any]], repo_name: str, owner: str) -> list[dict[str, Any]]:
    """Generate 3 releases (v0.1.0 draft, v0.2.0 arrangement, v1.0.0 full) for a repo."""
    if not commits:
        return []
    return [
        dict(repo_id=repo_id, tag="v0.1.0", title="Early Draft",
             body=f"## v0.1.0 â€” Early Draft\n\nFirst checkpoint. Basic groove locked in.\n\n### Tracks\n- Main groove\n- Bass foundation\n\n### Technical\nInitial BPM and key established.",
             commit_id=commits[min(4, len(commits)-1)]["commit_id"],
             download_urls={"midi_bundle": f"/releases/{repo_id}-v0.1.0.zip"},
             author=owner,
             created_at=_now(days=45)),
        dict(repo_id=repo_id, tag="v0.2.0", title="Arrangement Draft",
             body=f"## v0.2.0 â€” Arrangement Draft\n\nAll major sections sketched.\n\n### What's new\n- Additional instrument layers\n- Section transitions defined\n- Dynamic arc mapped",
             commit_id=commits[min(12, len(commits)-1)]["commit_id"],
             download_urls={"midi_bundle": f"/releases/{repo_id}-v0.2.0.zip", "mp3": f"/releases/{repo_id}-v0.2.0.mp3"},
             author=owner,
             created_at=_now(days=25)),
        dict(repo_id=repo_id, tag="v1.0.0", title=f"{repo_name} â€” Full Release",
             body=f"## v1.0.0 â€” Full Release\n\nProduction-ready state.\n\n### Highlights\n- Complete arrangement with all instruments\n- Mixed and mastered\n- Stems included\n\n### Downloads\nMIDI bundle, MP3 stereo mix, individual stems",
             commit_id=commits[-1]["commit_id"],
             download_urls={"midi_bundle": f"/releases/{repo_id}-v1.0.0.zip",
                            "mp3": f"/releases/{repo_id}-v1.0.0.mp3",
                            "stems": f"/releases/{repo_id}-v1.0.0-stems.zip"},
             author=owner,
             created_at=_now(days=5)),
    ]


# ---------------------------------------------------------------------------
# Session templates
# ---------------------------------------------------------------------------

def _make_sessions(repo_id: str, owner: str, commits: list[dict[str, Any]]) -> list[dict[str, Any]]:
    """Generate 6 collaboration sessions per repo; adds a live session for high-traffic repos."""
    if len(commits) < 2:
        return []
    sess = []
    collab_map: dict[str, list[tuple[str, ...]]] = {
        REPO_NEO_SOUL:     [("gabriel", "marcus"), ("gabriel",), ("gabriel", "marcus", "aaliya")],
        REPO_MODAL_JAZZ:   [("gabriel", "marcus"), ("gabriel",)],
        REPO_AMBIENT:      [("sofia", "yuki"), ("sofia",), ("sofia", "pierre")],
        REPO_AFROBEAT:     [("aaliya", "fatou"), ("aaliya",), ("aaliya", "marcus")],
        REPO_FUNK_SUITE:   [("marcus", "gabriel"), ("marcus",)],
        REPO_JAZZ_TRIO:    [("marcus",), ("marcus", "gabriel")],
        REPO_DRUM_MACHINE: [("fatou",), ("fatou", "aaliya")],
        REPO_CHANSON:      [("pierre",), ("pierre", "sofia")],
        REPO_GRANULAR:     [("yuki",), ("yuki", "sofia")],
        REPO_MICROTONAL:   [("chen",)],
    }
    collab_groups: list[tuple[str, ...]] = collab_map.get(repo_id) or [(owner,)]
    locations = [
        "Studio A, SÃ£o Paulo", "Home studio", "Remote",
        "Abbey Road Studio 3", "Electric Lady Studios", "Remote (async)",
        "Bedroom studio, Tokyo", "La Fabrique, Marseille",
    ]
    for i, group in enumerate((collab_groups * 3)[:6]):
        start_days = 60 - i * 8
        dur_hours = [3, 4, 2, 5, 2, 3][i % 6]
        commit_slice = commits[i * 4:i * 4 + 3] if len(commits) > i * 4 + 3 else commits[-2:]
        sess.append(dict(
            session_id=_uid(f"sess-{repo_id}-{i}"),
            repo_id=repo_id,
            started_at=_now(days=start_days),
            ended_at=_now(days=start_days, hours=-dur_hours),
            participants=list(group),
            location=locations[i % len(locations)],
            intent=f"Session {i+1}: extend arrangement and refine mix",
            commits=[c["commit_id"] for c in commit_slice],
            notes=f"Productive session. Focused on {'groove' if i % 2 == 0 else 'arrangement'}.",
            is_active=False,
            created_at=_now(days=start_days),
        ))
    # Add one live/active session for the first big repo
    if repo_id in (REPO_NEO_SOUL, REPO_AFROBEAT):
        sess.append(dict(
            session_id=_uid(f"sess-{repo_id}-live"),
            repo_id=repo_id,
            started_at=_now(hours=1),
            ended_at=None,
            participants=[owner, "marcus"],
            location="Studio A â€” Live",
            intent="Live recording session â€” tracking final takes",
            commits=[],
            notes="",
            is_active=True,
            created_at=_now(hours=1),
        ))
    return sess


# ---------------------------------------------------------------------------
# Main seed function
# ---------------------------------------------------------------------------

async def seed(db: AsyncSession, force: bool = False) -> None:
    """Populate all MuseHub tables with a realistic stress-test dataset.

    Inserts users, repos, commits, branches, issues, PRs, releases, sessions,
    social graph (stars, follows, watches, comments, reactions, notifications,
    forks, view/download events), and the full Muse VCS layer (objects,
    snapshots, commits, tags).  Pass force=True to wipe and re-seed existing data.
    """
    print("ðŸŒ± Seeding MuseHub stress-test datasetâ€¦")

    result = await db.execute(text("SELECT COUNT(*) FROM musehub_repos"))
    existing = result.scalar() or 0

    if existing > 0 and not force:
        print(f"  âš ï¸  {existing} repo(s) already exist â€” skipping. Pass --force to wipe and reseed.")
        _print_urls()
        return

    if existing > 0 and force:
        print("  ðŸ—‘  --force: clearing existing seed dataâ€¦")
        for tbl in [
            # Muse VCS â€” innermost first (tags depend on commits, commits depend on snapshots)
            "muse_tags", "muse_commits", "muse_snapshots", "muse_objects",
            # MuseHub
            "musehub_download_events", "musehub_view_events", "musehub_forks",
            "musehub_notifications", "musehub_watches", "musehub_follows",
            "musehub_reactions", "musehub_comments",
            "musehub_stars", "musehub_sessions", "musehub_releases",
            "musehub_webhook_deliveries", "musehub_webhooks",
            "musehub_pull_requests", "musehub_issues", "musehub_branches",
            "musehub_objects", "musehub_commits", "musehub_repos",
            "musehub_profiles",
        ]:
            await db.execute(text(f"DELETE FROM {tbl}"))
        await db.flush()

    # â”€â”€ 1. User profiles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    for uid, uname, bio in USERS:
        db.add(MusehubProfile(
            user_id=uid,
            username=uname,
            bio=bio,
            avatar_url=f"https://api.dicebear.com/7.x/avataaars/svg?seed={uname}",
            pinned_repo_ids=[],
        ))
    print(f"  âœ… Profiles: {len(USERS)} users")

    # â”€â”€ 2. Repos â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    for r in REPOS:
        db.add(MusehubRepo(
            repo_id=r["repo_id"],
            name=r["name"],
            owner=r["owner"],
            slug=r["slug"],
            owner_user_id=r["owner_user_id"],
            visibility=r["visibility"],
            description=r["description"],
            tags=r["tags"],
            key_signature=r["key_signature"],
            tempo_bpm=r["tempo_bpm"],
            created_at=_now(days=r["days_ago"]),
        ))
    print(f"  âœ… Repos: {len(REPOS)}")

    await db.flush()

    # â”€â”€ 3. Commits â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    all_commits: dict[str, list[dict[str, Any]]] = {}
    total_commits = 0
    for r in REPOS:
        repo_id = r["repo_id"]
        rkey = REPO_KEY_MAP.get(repo_id, "neo-soul")
        n = COMMIT_COUNTS.get(repo_id, 20)
        commits = _make_commits(repo_id, rkey, n)
        all_commits[repo_id] = commits
        total_commits += len(commits)
        for c in commits:
            db.add(MusehubCommit(**c))
        # Branches
        db.add(MusehubBranch(repo_id=repo_id, name="main",
                             head_commit_id=commits[-1]["commit_id"]))
        if len(commits) > 10:
            db.add(MusehubBranch(repo_id=repo_id, name="feat/develop",
                                 head_commit_id=commits[-4]["commit_id"]))
        if len(commits) > 20:
            db.add(MusehubBranch(repo_id=repo_id, name="experiment/alternate-harmony",
                                 head_commit_id=commits[-8]["commit_id"]))
    print(f"  âœ… Commits: {total_commits} across {len(REPOS)} repos")

    await db.flush()

    # â”€â”€ 4. Objects (track breakdown bar) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    obj_count = 0
    for r in REPOS:
        repo_id = r["repo_id"]
        rkey = REPO_KEY_MAP.get(repo_id, "neo-soul")
        tracks = REPO_TRACKS.get(rkey, REPO_TRACKS["neo-soul"])
        commits = all_commits.get(repo_id, [])
        if not commits:
            continue
        # Attach objects to the last 3 commits
        for commit in commits[-3:]:
            cid = commit["commit_id"]
            for role, path in tracks:
                obj_id = f"sha256:{_sha(f'{cid}-{path}')}"
                db.add(MusehubObject(
                    object_id=obj_id,
                    repo_id=repo_id,
                    path=path,
                    size_bytes=len(path) * 1024,
                    disk_path=f"/app/objects/{repo_id}/{obj_id[7:15]}.mid",
                    created_at=commit["timestamp"],
                ))
                obj_count += 1
    print(f"  âœ… Objects: {obj_count} track files")

    await db.flush()

    # â”€â”€ 5. Issues â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    issue_count = 0
    for r in REPOS:
        repo_id = r["repo_id"]
        rkey = REPO_KEY_MAP.get(repo_id, "neo-soul")
        issue_list = ISSUE_TEMPLATES.get(rkey, GENERIC_ISSUES)
        days_base = r["days_ago"]
        for iss in issue_list:
            db.add(MusehubIssue(
                repo_id=repo_id,
                number=iss["n"],
                state=iss["state"],
                title=iss["title"],
                body=iss["body"],
                labels=iss["labels"],
                author=r["owner"],
                created_at=_now(days=days_base - iss["n"] * 2),
            ))
            issue_count += 1
    print(f"  âœ… Issues: {issue_count}")

    await db.flush()

    # â”€â”€ 6. Pull Requests â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    pr_count = 0
    pr_ids: dict[str, list[str]] = {}
    for r in REPOS:
        repo_id = r["repo_id"]
        commits = all_commits.get(repo_id, [])
        prs = _make_prs(repo_id, commits, r["owner"])
        pr_ids[repo_id] = [p["pr_id"] for p in prs]
        for pr in prs:
            db.add(MusehubPullRequest(**pr))
            pr_count += 1
    print(f"  âœ… Pull Requests: {pr_count}")

    await db.flush()

    # â”€â”€ 7. Releases â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    release_count = 0
    release_tags: dict[str, list[str]] = {}
    for r in REPOS:
        repo_id = r["repo_id"]
        commits = all_commits.get(repo_id, [])
        releases = _make_releases(repo_id, commits, r["name"], r["owner"])
        release_tags[repo_id] = [rel["tag"] for rel in releases]
        for rel in releases:
            db.add(MusehubRelease(**rel))
            release_count += 1
    print(f"  âœ… Releases: {release_count}")

    await db.flush()

    # â”€â”€ 8. Sessions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    session_count = 0
    session_ids: dict[str, list[str]] = {}
    for r in REPOS:
        repo_id = r["repo_id"]
        commits = all_commits.get(repo_id, [])
        sessions = _make_sessions(repo_id, r["owner"], commits)
        session_ids[repo_id] = [s["session_id"] for s in sessions]
        for sess in sessions:
            db.add(MusehubSession(**sess))
            session_count += 1
    print(f"  âœ… Sessions: {session_count}")

    await db.flush()

    # â”€â”€ 9. Stars (cross-repo) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    star_pairs = [
        (SOFIA,   REPO_NEO_SOUL, 20),    (MARCUS, REPO_NEO_SOUL, 18),
        (YUKI,    REPO_NEO_SOUL, 15),    (AALIYA, REPO_NEO_SOUL, 12),
        (CHEN,    REPO_NEO_SOUL, 10),    (FATOU,  REPO_NEO_SOUL, 8),
        (PIERRE,  REPO_NEO_SOUL, 6),

        (GABRIEL, REPO_AMBIENT, 14),     (MARCUS, REPO_AMBIENT, 12),
        (YUKI,    REPO_AMBIENT, 10),     (AALIYA, REPO_AMBIENT, 9),
        (CHEN,    REPO_AMBIENT, 7),      (FATOU,  REPO_AMBIENT, 5),
        (PIERRE,  REPO_AMBIENT, 3),

        (GABRIEL, REPO_AFROBEAT, 8),     (SOFIA,  REPO_AFROBEAT, 7),
        (MARCUS,  REPO_AFROBEAT, 6),     (YUKI,   REPO_AFROBEAT, 5),
        (CHEN,    REPO_AFROBEAT, 4),     (PIERRE, REPO_AFROBEAT, 3),

        (GABRIEL, REPO_FUNK_SUITE, 12),  (SOFIA,  REPO_FUNK_SUITE, 10),
        (AALIYA,  REPO_FUNK_SUITE, 9),   (CHEN,   REPO_FUNK_SUITE, 7),
        (FATOU,   REPO_FUNK_SUITE, 5),

        (GABRIEL, REPO_MODAL_JAZZ, 11),  (SOFIA,  REPO_MODAL_JAZZ, 8),
        (MARCUS,  REPO_MODAL_JAZZ, 6),   (AALIYA, REPO_MODAL_JAZZ, 4),

        (GABRIEL, REPO_JAZZ_TRIO, 9),    (SOFIA,  REPO_JAZZ_TRIO, 7),
        (AALIYA,  REPO_JAZZ_TRIO, 5),    (CHEN,   REPO_JAZZ_TRIO, 3),

        (GABRIEL, REPO_DRUM_MACHINE, 6), (MARCUS, REPO_DRUM_MACHINE, 4),
        (GABRIEL, REPO_GRANULAR, 5),     (MARCUS, REPO_GRANULAR, 3),
        (GABRIEL, REPO_CHANSON, 4),      (SOFIA,  REPO_CHANSON, 3),
        (GABRIEL, REPO_MICROTONAL, 3),   (SOFIA,  REPO_MICROTONAL, 2),
    ]
    for user_id, repo_id, days in star_pairs:
        db.add(MusehubStar(repo_id=repo_id, user_id=user_id,
                           created_at=_now(days=days)))
    print(f"  âœ… Stars: {len(star_pairs)}")

    await db.flush()

    # â”€â”€ 10. Comments â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    COMMENT_BODIES = [
        "This groove is incredible â€” the 3-against-4 polyrhythm is exactly what this track needed.",
        "Love the Rhodes voicings here. Upper-structure triads give it that sophisticated neo-soul feel.",
        "The humanization really helped. Feels much more like a live performance now.",
        "I think the bridge needs more harmonic tension. The IV-I resolution is too settled.",
        "That trumpet counter-melody is stunning. It perfectly answers the Rhodes line.",
        "Could we push the bass a bit more? It's sitting a little behind the kick drum.",
        "The string pizzicato in the verse is a beautiful subtle touch.",
        "I'm not sure about the guitar scratch â€” feels a bit busy with the Rhodes.",
        "This is really coming together. The dynamic arc from intro to chorus is perfect.",
        "The call-and-response between horns and strings is very Quincy Jones.",
    ]

    comment_count = 0
    for r in REPOS[:6]:  # Comments on first 6 repos
        repo_id = r["repo_id"]
        commits = all_commits.get(repo_id, [])
        if not commits:
            continue
        # Comments on latest 3 commits
        for i, commit in enumerate(commits[-3:]):
            for j in range(3):
                body = COMMENT_BODIES[(i * 3 + j) % len(COMMENT_BODIES)]
                author_ids = [GABRIEL, SOFIA, MARCUS, YUKI, AALIYA, CHEN, FATOU, PIERRE]
                author = [u[1] for u in USERS if u[0] == author_ids[(i + j + hash(repo_id)) % len(author_ids)]][0]
                comment_id = _uid(f"comment-{repo_id}-{i}-{j}")
                db.add(MusehubComment(
                    comment_id=comment_id,
                    repo_id=repo_id,
                    target_type="commit",
                    target_id=commit["commit_id"],
                    author=author,
                    body=body,
                    parent_id=None,
                    created_at=_now(days=2, hours=i * 3 + j),
                ))
                comment_count += 1
                # Add a reply to first comment on each commit
                if j == 0:
                    reply_author = [u[1] for u in USERS if u[1] != author][0]
                    db.add(MusehubComment(
                        comment_id=_uid(f"reply-{repo_id}-{i}-{j}"),
                        repo_id=repo_id,
                        target_type="commit",
                        target_id=commit["commit_id"],
                        author=reply_author,
                        body="Totally agree â€” this part really elevates the whole track.",
                        parent_id=comment_id,
                        created_at=_now(days=1, hours=i * 2),
                    ))
                    comment_count += 1
    print(f"  âœ… Comments: {comment_count}")

    await db.flush()

    # â”€â”€ 11. Reactions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    EMOJIS = ["ðŸ”¥", "ðŸŽµ", "â¤ï¸", "ðŸ‘", "âœ¨", "ðŸŽ¸", "ðŸŽ¹", "ðŸ¥"]
    reaction_count = 0
    for r in REPOS[:6]:
        repo_id = r["repo_id"]
        commits = all_commits.get(repo_id, [])
        if not commits:
            continue
        for commit in commits[-5:]:
            for i, uid in enumerate([GABRIEL, SOFIA, MARCUS, YUKI, AALIYA]):
                emoji = EMOJIS[i % len(EMOJIS)]
                try:
                    db.add(MusehubReaction(
                        reaction_id=_uid(f"reaction-{repo_id}-{commit['commit_id'][:8]}-{uid}"),
                        repo_id=repo_id,
                        target_type="commit",
                        target_id=commit["commit_id"],
                        user_id=uid,
                        emoji=emoji,
                        created_at=_now(days=1),
                    ))
                    reaction_count += 1
                except Exception:
                    pass
    print(f"  âœ… Reactions: {reaction_count}")

    await db.flush()

    # â”€â”€ 12. Follows (social graph) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    follow_pairs = [
        (SOFIA, GABRIEL), (MARCUS, GABRIEL), (YUKI, GABRIEL),
        (AALIYA, GABRIEL), (CHEN, GABRIEL), (FATOU, GABRIEL),
        (GABRIEL, SOFIA), (MARCUS, SOFIA), (PIERRE, SOFIA),
        (GABRIEL, MARCUS), (SOFIA, MARCUS), (AALIYA, MARCUS),
        (GABRIEL, YUKI), (SOFIA, YUKI), (CHEN, YUKI),
        (GABRIEL, AALIYA), (MARCUS, AALIYA), (FATOU, AALIYA),
        (GABRIEL, CHEN), (YUKI, CHEN),
        (GABRIEL, FATOU), (AALIYA, FATOU),
        (GABRIEL, PIERRE), (SOFIA, PIERRE),
    ]
    for follower, followee in follow_pairs:
        db.add(MusehubFollow(
            follow_id=_uid(f"follow-{follower}-{followee}"),
            follower_id=follower,
            followee_id=followee,
            created_at=_now(days=15),
        ))
    print(f"  âœ… Follows: {len(follow_pairs)}")

    await db.flush()

    # â”€â”€ 13. Watches â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    watch_pairs = [
        (GABRIEL, REPO_AMBIENT), (GABRIEL, REPO_AFROBEAT), (GABRIEL, REPO_FUNK_SUITE),
        (SOFIA, REPO_NEO_SOUL), (SOFIA, REPO_FUNK_SUITE), (SOFIA, REPO_CHANSON),
        (MARCUS, REPO_NEO_SOUL), (MARCUS, REPO_AMBIENT), (MARCUS, REPO_AFROBEAT),
        (YUKI, REPO_AMBIENT), (YUKI, REPO_GRANULAR), (YUKI, REPO_MICROTONAL),
        (AALIYA, REPO_NEO_SOUL), (AALIYA, REPO_AFROBEAT), (AALIYA, REPO_FUNK_SUITE),
        (CHEN, REPO_MICROTONAL), (CHEN, REPO_AMBIENT), (CHEN, REPO_GRANULAR),
        (FATOU, REPO_AFROBEAT), (FATOU, REPO_DRUM_MACHINE),
        (PIERRE, REPO_CHANSON), (PIERRE, REPO_AMBIENT),
    ]
    for user_id, repo_id in watch_pairs:
        db.add(MusehubWatch(
            watch_id=_uid(f"watch-{user_id}-{repo_id}"),
            user_id=user_id,
            repo_id=repo_id,
            created_at=_now(days=10),
        ))
    print(f"  âœ… Watches: {len(watch_pairs)}")

    await db.flush()

    # â”€â”€ 14. Notifications â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    EVENT_TYPES = ["comment", "pr_opened", "pr_merged", "issue_opened", "new_commit", "new_follower"]
    notif_count = 0
    for i, (uid, uname, _) in enumerate(USERS[:4]):
        for j in range(8):
            db.add(MusehubNotification(
                notif_id=_uid(f"notif-{uid}-{j}"),
                recipient_id=uid,
                event_type=EVENT_TYPES[j % len(EVENT_TYPES)],
                repo_id=REPOS[j % len(REPOS)]["repo_id"],
                actor=USERS[(i + j + 1) % len(USERS)][1],
                payload={"message": f"Sample notification {j+1} for {uname}"},
                is_read=j < 3,
                created_at=_now(days=j),
            ))
            notif_count += 1
    print(f"  âœ… Notifications: {notif_count}")

    await db.flush()

    # â”€â”€ 15. Forks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    db.add(MusehubFork(
        fork_id=_uid("fork-neo-soul-marcus"),
        source_repo_id=REPO_NEO_SOUL,
        fork_repo_id=REPO_NEO_SOUL_FORK,
        forked_by="marcus",
        created_at=_now(days=10),
    ))
    db.add(MusehubFork(
        fork_id=_uid("fork-ambient-yuki"),
        source_repo_id=REPO_AMBIENT,
        fork_repo_id=REPO_AMBIENT_FORK,
        forked_by="yuki",
        created_at=_now(days=5),
    ))
    print("  âœ… Forks: 2")

    await db.flush()

    # â”€â”€ 16. View events (analytics) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    view_count = 0
    for r in REPOS[:8]:
        repo_id = r["repo_id"]
        for day_offset in range(30):
            date_str = (_now(days=day_offset)).strftime("%Y-%m-%d")
            viewers = r["star_count"] // 3 + 1
            for v in range(min(viewers, 10)):
                try:
                    db.add(MusehubViewEvent(
                        view_id=_uid(f"view-{repo_id}-{day_offset}-{v}"),
                        repo_id=repo_id,
                        viewer_fingerprint=_sha(f"viewer-{repo_id}-{v}"),
                        event_date=date_str,
                        created_at=_now(days=day_offset),
                    ))
                    view_count += 1
                except Exception:
                    pass
    print(f"  âœ… View events: {view_count}")

    await db.flush()

    # â”€â”€ 17. Download events â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    dl_count = 0
    for r in REPOS[:6]:
        repo_id = r["repo_id"]
        for i in range(8):
            db.add(MusehubDownloadEvent(
                dl_id=_uid(f"dl-{repo_id}-{i}"),
                repo_id=repo_id,
                ref="main",
                downloader_id=[u[0] for u in USERS][i % len(USERS)],
                created_at=_now(days=i * 3),
            ))
            dl_count += 1
    print(f"  âœ… Download events: {dl_count}")

    # â”€â”€ 18. Muse VCS â€” muse_objects, muse_snapshots, muse_commits, muse_tags â”€
    #
    # Inserts content-addressed MIDI blobs, snapshot manifests, a proper DAG
    # of Muse commits (including merge commits), and the full tag taxonomy.
    #
    # Insertion order respects FK constraints:
    #   muse_objects â†’ muse_snapshots â†’ muse_commits â†’ muse_tags
    #
    muse_obj_count = 0
    muse_snap_count = 0
    muse_commit_count = 0
    muse_tag_count = 0

    # Running objects pool so the same content can be deduplicated across
    # snapshots (object_ids that haven't changed reuse the same sha256).
    # Structure: repo_id â†’ {filename: object_id}
    _prev_objects: dict[str, dict[str, str]] = {}

    for r in REPOS:
        repo_id = r["repo_id"]
        hub_commits = all_commits.get(repo_id, [])
        if not hub_commits:
            continue

        track_files = MUSE_VCS_FILES.get(repo_id, MUSE_VCS_FILES[REPO_AMBIENT])
        meta = MUSE_COMMIT_META.get(repo_id, MUSE_COMMIT_META[REPO_AMBIENT])
        is_rich = repo_id in MUSE_RICH_TAG_REPOS

        prev_objects: dict[str, str] = {}  # filename â†’ object_id for this repo
        muse_commit_ids: list[str] = []    # ordered muse commit_ids for this repo

        for i, hub_c in enumerate(hub_commits):
            snap_seed = f"snap-muse-{repo_id}-{i}"
            committed_at = hub_c["timestamp"]

            # Build this commit's object set.
            # Every commit, ~2 files "change" (get fresh object_ids).
            # The rest reuse from the previous commit â€” simulating deduplication.
            changed_indices = {i % len(track_files), (i + 2) % len(track_files)}
            commit_objects: dict[str, str] = {}

            for fi, (fname, base_size) in enumerate(track_files):
                if fi in changed_indices or fname not in prev_objects:
                    # New or modified file â†’ fresh content-addressed blob.
                    obj_id = _sha(f"midi-{repo_id}-{fname}-v{i}")
                    size = base_size + (i * 128) % 4096
                    await db.execute(
                        text(
                            "INSERT INTO muse_objects (object_id, size_bytes, created_at)"
                            " VALUES (:oid, :sz, :ca)"
                            " ON CONFLICT (object_id) DO NOTHING"
                        ),
                        {"oid": obj_id, "sz": size, "ca": committed_at},
                    )
                    muse_obj_count += 1
                else:
                    # Unchanged file â†’ reuse previous object_id (deduplication).
                    obj_id = prev_objects[fname]
                commit_objects[fname] = obj_id

            prev_objects = commit_objects

            # Snapshot â€” manifest maps track paths to object_ids.
            snapshot_id = _sha(snap_seed)
            manifest: dict[str, str] = {f"tracks/{fname}": oid for fname, oid in commit_objects.items()}
            await db.execute(
                text(
                    "INSERT INTO muse_snapshots (snapshot_id, manifest, created_at)"
                    " VALUES (:sid, :manifest, :ca)"
                    " ON CONFLICT (snapshot_id) DO NOTHING"
                ),
                {"sid": snapshot_id, "manifest": manifest, "ca": committed_at},
            )
            muse_snap_count += 1

            # Muse commit â€” derives its ID from snapshot + parent + message.
            parent_id: str | None = muse_commit_ids[-1] if muse_commit_ids else None
            # Merge commit every 7 commits (from commit 7 onward) â€” parent2 is the
            # commit from 5 positions back, simulating a merged feature branch.
            # Interval of 7 guarantees â‰¥5 merges per repo for repos with â‰¥35 commits.
            parent2_id: str | None = None
            if i >= 7 and i % 7 == 0 and len(muse_commit_ids) >= 6:
                parent2_id = muse_commit_ids[-6]

            commit_id = _sha(f"muse-c-{snapshot_id}-{parent_id or ''}-{hub_c['message']}")
            await db.execute(
                text(
                    "INSERT INTO muse_commits"
                    " (commit_id, repo_id, branch, parent_commit_id, parent2_commit_id,"
                    "  snapshot_id, message, author, committed_at, created_at, metadata)"
                    " VALUES"
                    " (:cid, :rid, :branch, :pid, :p2id,"
                    "  :sid, :msg, :author, :cat, :cat, :meta)"
                    " ON CONFLICT (commit_id) DO NOTHING"
                ),
                {
                    "cid":    commit_id,
                    "rid":    repo_id,
                    "branch": hub_c["branch"],
                    "pid":    parent_id,
                    "p2id":   parent2_id,
                    "sid":    snapshot_id,
                    "msg":    hub_c["message"],
                    "author": hub_c["author"],
                    "cat":    committed_at,
                    "meta":   meta,
                },
            )
            muse_commit_ids.append(commit_id)
            muse_commit_count += 1

            # Tags: apply cycling taxonomy to every commit.
            # Rich repos get ALL taxonomy values; others get a representative subset.
            if is_rich:
                # Cycle through all 57 tag values across commits so every value appears.
                tag_val = _ALL_MUSE_TAGS[i % len(_ALL_MUSE_TAGS)]
                tag_vals = [tag_val]
                # Also add a second tag from a different category group.
                second_idx = (i + len(MUSE_EMOTION_TAGS)) % len(_ALL_MUSE_TAGS)
                if second_idx != i % len(_ALL_MUSE_TAGS):
                    tag_vals.append(_ALL_MUSE_TAGS[second_idx])
            else:
                # Non-rich repos get one tag per commit drawn from a trimmed pool.
                _trimmed = MUSE_EMOTION_TAGS + MUSE_STAGE_TAGS + MUSE_GENRE_TAGS
                tag_vals = [_trimmed[i % len(_trimmed)]]

            for tag_val in tag_vals:
                tag_id = _uid(f"muse-tag-{commit_id}-{tag_val}")
                await db.execute(
                    text(
                        "INSERT INTO muse_tags (tag_id, repo_id, commit_id, tag, created_at)"
                        " VALUES (:tid, :rid, :cid, :tag, :ca)"
                        " ON CONFLICT (tag_id) DO NOTHING"
                    ),
                    {"tid": tag_id, "rid": repo_id, "cid": commit_id,
                     "tag": tag_val, "ca": committed_at},
                )
                muse_tag_count += 1

        _prev_objects[repo_id] = prev_objects

    # Ensure every tag taxonomy value appears at least once in REPO_NEO_SOUL.
    # Walk through ALL values and seed any that haven't been covered yet.
    if all_commits.get(REPO_NEO_SOUL):
        hub_commits_ns = all_commits[REPO_NEO_SOUL]
        muse_ids_ns: list[str] = []
        for i, hub_c in enumerate(hub_commits_ns):
            snap_seed = f"snap-muse-{REPO_NEO_SOUL}-{i}"
            snapshot_id = _sha(snap_seed)
            parent_id_ns: str | None = muse_ids_ns[-1] if muse_ids_ns else None
            commit_id_ns = _sha(f"muse-c-{snapshot_id}-{parent_id_ns or ''}-{hub_c['message']}")
            muse_ids_ns.append(commit_id_ns)

        # Fetch existing tags for REPO_NEO_SOUL.
        result = await db.execute(
            text("SELECT tag FROM muse_tags WHERE repo_id = :rid"),
            {"rid": REPO_NEO_SOUL},
        )
        existing_tags: set[str] = {row[0] for row in result.fetchall()}
        missing_tags = [t for t in _ALL_MUSE_TAGS if t not in existing_tags]

        for j, missing_tag in enumerate(missing_tags):
            commit_id_ns = muse_ids_ns[j % len(muse_ids_ns)]
            committed_at_ns = hub_commits_ns[j % len(hub_commits_ns)]["timestamp"]
            tag_id = _uid(f"muse-tag-fill-{REPO_NEO_SOUL}-{missing_tag}")
            await db.execute(
                text(
                    "INSERT INTO muse_tags (tag_id, repo_id, commit_id, tag, created_at)"
                    " VALUES (:tid, :rid, :cid, :tag, :ca)"
                    " ON CONFLICT (tag_id) DO NOTHING"
                ),
                {"tid": tag_id, "rid": REPO_NEO_SOUL, "cid": commit_id_ns,
                 "tag": missing_tag, "ca": committed_at_ns},
            )
            muse_tag_count += 1

    await db.flush()
    print(f"  âœ… Muse objects:    {muse_obj_count} blobs")
    print(f"  âœ… Muse snapshots:  {muse_snap_count} manifests")
    print(f"  âœ… Muse commits:    {muse_commit_count} (DAG; includes merge commits)")
    print(f"  âœ… Muse tags:       {muse_tag_count} (full taxonomy)")

    await db.commit()
    print()
    _print_urls(all_commits, session_ids, pr_ids, release_tags)


def _print_urls(
    all_commits: dict[str, list[dict[str, Any]]] | None = None,
    session_ids: dict[str, list[str]] | None = None,
    pr_ids: dict[str, list[str]] | None = None,
    release_tags: dict[str, list[str]] | None = None,
) -> None:
    """Print all seeded MuseHub URLs to stdout for manual browser verification."""
    BASE = "http://localhost:10001/musehub/ui"
    print()
    print("=" * 72)
    print("ðŸŽµ  MUSEHUB â€” ALL URLs (localhost:10001)")
    print("=" * 72)

    print("\nâ”€â”€ User profiles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    for _, uname, _ in USERS:
        print(f"  {BASE}/users/{uname}")
        print(f"  {BASE}/{uname}  (redirects â†’ above)")

    print("\nâ”€â”€ Explore / discover â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    print(f"  {BASE}/explore")
    print(f"  {BASE}/trending")
    print(f"  {BASE}/search")
    print(f"  {BASE}/feed")

    for r in REPOS[:8]:  # Skip fork repos from URL dump
        owner, slug = r["owner"], r["slug"]
        repo_id = r["repo_id"]
        rbase = f"{BASE}/{owner}/{slug}"

        print(f"\nâ”€â”€ {owner}/{slug} â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
        print(f"  Repo:      {rbase}")
        print(f"  Graph:     {rbase}/graph")
        print(f"  Timeline:  {rbase}/timeline")
        print(f"  Insights:  {rbase}/insights")
        print(f"  Credits:   {rbase}/credits")
        print(f"  Search:    {rbase}/search")

        if all_commits and repo_id in all_commits:
            commits = all_commits[repo_id]
            for c in commits[-3:]:
                print(f"  Commit:    {rbase}/commits/{c['commit_id'][:12]}")
            if commits:
                print(f"  Diff:      {rbase}/commits/{commits[-1]['commit_id'][:12]}/diff")

        print(f"  Issues:    {rbase}/issues")
        print(f"  PRs:       {rbase}/pulls")
        print(f"  Releases:  {rbase}/releases")
        if release_tags and repo_id in release_tags:
            for tag in release_tags[repo_id]:
                print(f"             {rbase}/releases/{tag}")
        print(f"  Sessions:  {rbase}/sessions")
        if session_ids and repo_id in session_ids:
            for sid in session_ids[repo_id][:2]:
                print(f"             {rbase}/sessions/{sid}")
        print(f"  Divergence:{rbase}/divergence")
        print(f"  Context:   {rbase}/context/main")
        print(f"  Analysis:  {rbase}/analysis/main/contour")
        print(f"             {rbase}/analysis/main/tempo")
        print(f"             {rbase}/analysis/main/dynamics")

    print()
    print("=" * 72)
    print("âœ…  Seed complete.")
    print("=" * 72)


async def main() -> None:
    """CLI entry point. Pass --force to wipe existing seed data before re-seeding."""
    force = "--force" in sys.argv
    db_url: str = settings.database_url or ""
    engine = create_async_engine(db_url, echo=False)
    async_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)  # type: ignore[call-overload]  # SQLAlchemy typing: sessionmaker + class_=AsyncSession overload not reflected in stubs
    async with async_session() as db:
        await seed(db, force=force)
    await engine.dispose()


if __name__ == "__main__":
    asyncio.run(main())
