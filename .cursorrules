# Stori Maestro ‚Äî Agent Rules

Use these rules when editing this codebase. They keep behavior consistent, tests strong, and docs accurate for go-live and open source.

---

## Project identity

- **What it is:** Stori Maestro ‚Äî AI-powered music composition backend for the Stori DAW (FastAPI + MCP). Tagline: "the infinite music machine."
- **Client:** The Stori DAW is a **macOS app** (Swift/SwiftUI, AppKit). It is NOT an iOS app. Never say "iOS app" ‚Äî always say "macOS app" or "the app".
- **Entry points:** (1) **Stream first:** `POST /api/v1/maestro/stream` (human in the macOS app). (2) **MCP:** tools exposed to Cursor/Claude; same engine, same DAW instance. Human stays in the loop.
- **Stack:** Python 3.11+, FastAPI, Pydantic v2, async throughout. Orpheus is **required** for music generation (no pattern fallback). Config: `app/config.py`; env vars prefixed `STORI_*`.
- **Versioning:** One semver version in `pyproject.toml` ‚Äî the single source of truth. `app/protocol/version.py` reads it; everything else (`config.py`, `main.py`, MCP server, health endpoint, SSE `protocolVersion` field) derives from there. When bumping, only edit `pyproject.toml`.
- **Supported models (exactly two, no others):** `anthropic/claude-sonnet-4.6` and `anthropic/claude-opus-4.6` via OpenRouter. Do not add support for any other provider, model family, or version. Update both `ALLOWED_MODEL_IDS` and `CONTEXT_WINDOW_TOKENS` in `app/config.py` together when a new Claude generation ships.

---

## Architecture (do not weaken)

- **Intent-first:** Classify every request ‚Üí REASONING (chat only) / EDITING (DAW tools, allowlist) / COMPOSING (planner ‚Üí executor + Orpheus).
- **Orpheus required:** If Orpheus is down, generation fails with a clear error. Do not reintroduce pattern fallback or optional Orpheus.
- **Single engine:** Stream and MCP use the same pipeline, tools, and (when connected) DAW state. Keep route handlers thin; core logic in `app/core/` and `app/services/`.
- **Entity resolution:** Server resolves variable refs (e.g. `$0.trackId`) and validates entity IDs; never trust client-provided IDs for security.
- **No deprecated/legacy/fallback APIs:** Never introduce deprecated, backward-compatible, or fallback API paths, event types, or optional fields "for transition." The same person controls the frontend and backend ‚Äî both ship in lockstep. Every API surface should be modern and pristine. If a field is needed, make it required. If an event type is superseded, delete the old one immediately. If you encounter dead code, fallback paths, or deprecated patterns while working, remove them proactively ‚Äî treat them like lint. Only add backward compat if explicitly requested.
- **Correct over simple:** Don't default to the simplest approach ‚Äî default to the correct one. In the best case they're the same thing, but when they diverge, choose correct.

---

## Execution environment

- **Docker-first:** All Python execution (scripts, syntax checks, linting, mypy, pytest, coverage, `python -c`) MUST run inside the Docker container. **Never** run Python directly on the host. Use `docker compose exec maestro <command>` for everything. If the container is not running, start it first with `docker compose up -d`. If code has changed, rebuild first: `docker compose build maestro && docker compose up -d`.
- **Quick syntax check:** `docker compose exec maestro python -c "import py_compile; py_compile.compile('<file>', doraise=True)"`.
- **Mypy:** `docker compose exec maestro mypy app/ tests/`.
- **Tests:** `docker compose exec maestro pytest tests/ -v`.

---

## Coding standards

- **Style:** Black-compatible formatting. Prefer short, readable names; avoid abbreviations unless standard (e.g. `id`, `db`, `api`).
- **Typing:** Use type hints for all public functions and module boundaries. Use `list[...]`, `dict[...]` (Python 3.9+ style). Mark optional with `Optional[...]` or `X | None` where appropriate. Run **mypy** before committing: `mypy app/ tests/` (or in Docker: `docker compose exec maestro mypy app/ tests/`). CI runs mypy; do not add `# type: ignore` without a short comment. New code should satisfy mypy with the project config in `pyproject.toml` ([tool.mypy]).
- **Async:** Use `async def` and `await` for I/O (DB, HTTP, Orpheus, LLM). Use `@pytest.mark.anyio` or `asyncio_mode = "auto"` for async tests; prefer `anyio` where fixtures are async.
- **Imports:** Group stdlib, third-party, then `app.*`. Prefer explicit imports; avoid `*` except for re-exports in `__init__.py`.
- **Config:** Read from `app.config.settings` (Pydantic Settings). No hardcoded secrets; no committing `.env` or keys. Use `STORI_*` env vars as documented in `docs/guides/setup.md`.
- **Logging:** Always use `logging.getLogger(__name__)` ‚Äî never `print()`. Use appropriate levels: `logger.debug()` for internals, `logger.info()` for lifecycle events, `logger.warning()` for recoverable issues, `logger.error()` for failures. Log level is controlled app-wide via `STORI_LOG_LEVEL` env var (default `INFO`). If you see a `print()` in existing code, replace it with the correct `logger.*` call. Never commit `print()` statements for diagnostics ‚Äî they bypass level filtering, cannot be silenced in production, and pollute stdout. **Keep logs sparse** ‚Äî only log what would genuinely help diagnose a production issue; remove routine "entering function" or "operation succeeded" noise. **Use emojis** in log messages where they add at-a-glance clarity: e.g. `‚ùå` for errors, `‚ö†Ô∏è` for warnings, `‚úÖ` for significant successes, `üî¥` for critical failures. Keep emoji use consistent and purposeful ‚Äî one per message, at the start.
- **Errors:** Prefer clear, user-facing messages for API errors. Log with `logging` at appropriate levels; avoid printing secrets or full tracebacks to responses.
- **Security:** Keep security headers (see `SecurityHeadersMiddleware` in `main.py`). Validate and sanitize inputs; use auth dependencies for protected routes. See `docs/guides/security.md` for go-live checklist.

---

## Tests

- **Runner:** The container copies code at build time (no live volume mount). **Always rebuild before testing:** `docker compose build maestro && docker compose up -d`, then `docker compose exec maestro pytest tests/ -v`. **Coverage (canonical, from container):** `docker compose exec maestro sh -c "export COVERAGE_FILE=/tmp/.coverage && python -m coverage run -m pytest tests/ -v && python -m coverage report --fail-under=80 --show-missing"`. Threshold is in `pyproject.toml` ([tool.coverage.report] fail_under). See `docs/guides/testing.md`.
- **When to run tests yourself vs. ask the user:** Run individual tests or individual test files directly (e.g. `pytest tests/test_foo.py -v` or `pytest tests/test_foo.py::TestBar::test_baz -v`). **Do NOT run the full suite** (`pytest tests/ -v`) ‚Äî the user runs that manually. If the full suite needs to run, tell the user and let them do it. They will pass back any failures or stack traces for you to fix. This avoids agent loops on full-suite failures.
- **Layout:** One test module per app area (e.g. `test_health.py`, `test_intent.py`, `test_rag.py`). Use `tests/conftest.py` for shared fixtures (`client`, `db_session`). Do not commit tests that depend on live external APIs (Orpheus, OpenRouter, S3) unless skipped or gated (e.g. `@pytest.mark.skip`, `skipif` with env).
- **Naming:** `test_<behavior>_<scenario>` or `test_<module>_<behavior>`. Docstrings: one line describing what is being tested.
- **Fixtures:** Prefer `db_session` and `client` from conftest for API tests so auth and DB use the in-memory DB. Override dependencies via `app.dependency_overrides` in fixtures, and restore in `finally`.
- **Coverage:** Aim for high coverage on `app/core/`, `app/services/`, and `app/api/routes/`. Critical paths: intent classification, pipeline (REASONING/EDITING/COMPOSING), executor, tool validation, RAG, health. When adding features, add or extend tests; when fixing bugs, add a regression test if missing.
- **Regression tests (mandatory):** Every bug fix, behavioral change, or contract update MUST include at least one regression test that would have caught the original issue. Place regression tests in the relevant test module next to existing tests for that area. Name them `test_<what_broke>_<fixed_behavior>` (e.g. `test_drumkitid_forces_is_drums_true`, `test_invalid_color_replaced_with_named`). The test should assert the corrected behavior *and* verify the old broken behavior no longer occurs. Do not consider a fix complete until its regression test passes.
- **Stability:** Avoid flaky tests (no sleep-based waits; mock external calls; use deterministic data). Mark known-unstable tests with `@pytest.mark.skip(reason="...")` and a short reason or ticket.
- **After tests pass:** Once the relevant tests pass, (1) verify that docs affected by the change are up to date (architecture, API reference, guides ‚Äî see Documentation section), then (2) commit everything unless the user explicitly says otherwise. Do not wait to be asked ‚Äî passing tests + updated docs = ready to commit.
- **Supercharging (optional):** Add contract/API tests for public endpoints (status codes, response shape). Add a few E2E-style tests for critical flows (e.g. stream one COMPOSING request). Consider property-based tests for serialization/validation in `app/core/` and `app/models/`. Keep CI fast: separate slow/integration tests if needed (e.g. markers).

---

## Documentation

- **Index:** `docs/README.md` is the entry point. Point users and contributors there.
- **Where to document:** Setup/config/deploy ‚Üí `docs/guides/setup.md`. Frontend/MCP/JWT ‚Üí `docs/guides/integrate.md`. Streaming, models, tools ‚Üí `docs/reference/api.md`. Request flow, intent, human/agent ‚Üí `docs/reference/architecture.md`. Running tests, intent QA ‚Üí `docs/guides/testing.md`. Assets (kits, soundfonts) ‚Üí `docs/guides/assets.md`. Security and go-live ‚Üí `docs/guides/security.md`. Specs (Muse/Variation) ‚Üí `docs/protocol/`.
- **When editing:** If you change behavior, config, or API, update the relevant doc. Prefer short, concrete sentences. Keep README and docs in sync (e.g. service table, env list).
- **Code comments:** Use docstrings for public modules, classes, and functions. Prefer "why" over "what" where non-obvious. Do not comment out code; remove or guard behind a feature flag.
- **Ephemeral handoff prompts:** Never create `.md` files for one-off FE/BE integration prompts or cross-team handoffs. Deliver them inline in the conversation as a fenced markdown block the user can copy. Only commit docs that are durable reference material (guides, API contracts, architecture).

---

## HTTP & streaming requests

- **SSE / streaming curl:** When making `curl` requests to streaming endpoints (SSE, chunked responses), **never truncate** the output. The terminal must stay **open and visible** so the user can watch events arrive in real time. Use a generous `block_until_ms` (e.g. `300000` for 5 minutes) so the terminal panel stays open for the full duration of the stream. Do **not** use `block_until_ms: 0` ‚Äî that backgrounds the process and the terminal flashes closed immediately, which defeats the purpose.
- **Real-time visibility matters:** The user wants to see every SSE event as it arrives ‚Äî heartbeats, chain-of-thought reasoning, toolStart, toolCall, planStepUpdate, errors, everything. The terminal must remain open and scrolling live for the entire duration of the request. After the stream completes, the user will report back with results or paste output for analysis.
- **E2E test prompt:** When curling `/api/v1/maestro/stream` to test the system, always use the `e2e_pocket_groove` prompt from `app/data/maestro_ui/prompts_global.py`. This is a compact, spec-complete STORI PROMPT (8 bars, 3 instruments, `Mode: compose`). Never use `mode: "generate"` in the STORI PROMPT ‚Äî every STORI PROMPT must be `Mode: compose`. The HTTP payload field `mode` is a separate concern (defaults to `"generate"` for new compositions, `"edit"` for modifications).
- **Ephemeral scripts:** Any throwaway scripts (Python, shell, etc.) used for testing, data extraction, or one-off tasks must be written to `/tmp/`, never inside the repo tree. This prevents them from appearing in `git status` or accidentally being committed. Clean up after use when practical.

---

## Before go-live / open source

- Run full test suite and fix any new failures or flakiness.
- Ensure no secrets or internal URLs in code or committed config; use env and `docs/guides/setup.md` for required vars.
- Confirm health endpoint exposes `tagline` and full health checks Orpheus (and optionally LLM/S3) as documented.
- Review `docs/guides/security.md` and apply the checklist (headers, rate limits, auth, logging).
- Keep README and docs accurate: service table, ports (10001‚Äì10099 block), and "Stream first, then MCP" messaging.
- When adding dependencies, update `pyproject.toml` and any Docker/CI that installs them.

---

## Quick reference

| Area        | Location              | Tests / Docs              |
|------------|------------------------|----------------------------|
| Config     | `app/config.py`                    | `tests/test_config.py`            |
| Health     | `app/api/routes/health.py`         | `tests/test_health.py`            |
| Intent     | `app/core/intent*.py`              | `tests/test_intent*.py`           |
| Pipeline   | `app/core/pipeline.py`             | `tests/test_pipeline.py`          |
| Maestro    | `app/core/maestro_handlers.py`     | `tests/test_maestro_handlers.py`  |
| Agent Teams| `app/core/maestro_agent_teams/`    | `tests/test_section_agent.py`, `tests/test_sections.py` |
| Telemetry  | `app/core/telemetry.py`            | `tests/test_telemetry.py`             |
| Executor   | `app/core/executor.py`             | `tests/test_executor.py`          |
| RAG        | `app/services/rag.py`              | `tests/test_rag.py`               |
| MCP        | `app/mcp/`, routes                 | `tests/test_mcp.py`               |
| Auth       | `app/auth/`                        | `tests/test_auth*.py`             |
| DB         | `app/db/`                          | `tests/test_database.py`          |
| Docs index | ‚Äî                                  | `docs/README.md`                  |
| Mypy       | `pyproject.toml` [tool.mypy]       | `mypy app/ tests/` (CI + pre-commit) |
