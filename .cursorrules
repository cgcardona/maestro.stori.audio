# Stori Composer — Agent Rules

Use these rules when editing this codebase. They keep behavior consistent, tests strong, and docs accurate for go-live and open source.

---

## Project identity

- **What it is:** Stori Composer — AI-powered music composition backend for the Stori DAW (FastAPI + MCP). Tagline: "the infinite music machine."
- **Entry points:** (1) **Stream first:** `POST /api/v1/compose/stream` (human in the app). (2) **MCP:** tools exposed to Cursor/Claude; same engine, same DAW instance. Human stays in the loop.
- **Stack:** Python 3.11+, FastAPI, Pydantic v2, async throughout. Orpheus is **required** for music generation (no pattern fallback). Config: `app/config.py`; env vars prefixed `STORI_*`.

---

## Architecture (do not weaken)

- **Intent-first:** Classify every request → REASONING (chat only) / EDITING (DAW tools, allowlist) / COMPOSING (planner → executor + Orpheus).
- **Orpheus required:** If Orpheus is down, generation fails with a clear error. Do not reintroduce pattern fallback or optional Orpheus.
- **Single engine:** Stream and MCP use the same pipeline, tools, and (when connected) DAW state. Keep route handlers thin; core logic in `app/core/` and `app/services/`.
- **Entity resolution:** Server resolves variable refs (e.g. `$0.trackId`) and validates entity IDs; never trust client-provided IDs for security.

---

## Coding standards

- **Style:** Black-compatible formatting. Prefer short, readable names; avoid abbreviations unless standard (e.g. `id`, `db`, `api`).
- **Typing:** Use type hints for all public functions and module boundaries. Use `list[...]`, `dict[...]` (Python 3.9+ style). Mark optional with `Optional[...]` or `X | None` where appropriate. Run **mypy** before committing: `mypy app/ tests/` (or in Docker: `docker compose exec composer mypy app/ tests/`). CI runs mypy; do not add `# type: ignore` without a short comment. New code should satisfy mypy with the project config in `pyproject.toml` ([tool.mypy]).
- **Async:** Use `async def` and `await` for I/O (DB, HTTP, Orpheus, LLM). Use `@pytest.mark.anyio` or `asyncio_mode = "auto"` for async tests; prefer `anyio` where fixtures are async.
- **Imports:** Group stdlib, third-party, then `app.*`. Prefer explicit imports; avoid `*` except for re-exports in `__init__.py`.
- **Config:** Read from `app.config.settings` (Pydantic Settings). No hardcoded secrets; no committing `.env` or keys. Use `STORI_*` env vars as documented in `docs/guides/setup.md`.
- **Errors:** Prefer clear, user-facing messages for API errors. Log with `logging` at appropriate levels; avoid printing secrets or full tracebacks to responses.
- **Security:** Keep security headers (see `SecurityHeadersMiddleware` in `main.py`). Validate and sanitize inputs; use auth dependencies for protected routes. See `docs/guides/security.md` for go-live checklist.

---

## Tests

- **Runner:** From repo root with stack running: `docker compose exec composer pytest tests/ -v`. **Coverage (canonical, from container):** `docker compose exec composer sh -c "export COVERAGE_FILE=/tmp/.coverage && python -m coverage run -m pytest tests/ -v && python -m coverage report --fail-under=64 --show-missing"`. Threshold is in `pyproject.toml` ([tool.coverage.report] fail_under). See `docs/guides/testing.md` (rebuild image if `coverage` is missing).
- **Layout:** One test module per app area (e.g. `test_health.py`, `test_intent.py`, `test_rag.py`). Use `tests/conftest.py` for shared fixtures (`client`, `db_session`). Do not commit tests that depend on live external APIs (Orpheus, OpenRouter, S3) unless skipped or gated (e.g. `@pytest.mark.skip`, `skipif` with env).
- **Naming:** `test_<behavior>_<scenario>` or `test_<module>_<behavior>`. Docstrings: one line describing what is being tested.
- **Fixtures:** Prefer `db_session` and `client` from conftest for API tests so auth and DB use the in-memory DB. Override dependencies via `app.dependency_overrides` in fixtures, and restore in `finally`.
- **Coverage:** Aim for high coverage on `app/core/`, `app/services/`, and `app/api/routes/`. Critical paths: intent classification, pipeline (REASONING/EDITING/COMPOSING), executor, tool validation, RAG, health. When adding features, add or extend tests; when fixing bugs, add a regression test if missing.
- **Stability:** Avoid flaky tests (no sleep-based waits; mock external calls; use deterministic data). Mark known-unstable tests with `@pytest.mark.skip(reason="...")` and a short reason or ticket.
- **Supercharging (optional):** Add contract/API tests for public endpoints (status codes, response shape). Add a few E2E-style tests for critical flows (e.g. stream one COMPOSING request). Consider property-based tests for serialization/validation in `app/core/` and `app/models/`. Keep CI fast: separate slow/integration tests if needed (e.g. markers).

---

## Documentation

- **Index:** `docs/README.md` is the entry point. Point users and contributors there.
- **Where to document:** Setup/config/deploy → `docs/guides/setup.md`. Frontend/MCP/JWT → `docs/guides/integrate.md`. Streaming, models, tools → `docs/reference/api.md`. Request flow, intent, human/agent → `docs/reference/architecture.md`. Running tests, intent QA → `docs/guides/testing.md`. Assets (kits, soundfonts) → `docs/guides/assets.md`. Security and go-live → `docs/guides/security.md`. Specs (Muse/Variation) → `docs/protocol/`.
- **When editing:** If you change behavior, config, or API, update the relevant doc. Prefer short, concrete sentences. Keep README and docs in sync (e.g. service table, env list).
- **Code comments:** Use docstrings for public modules, classes, and functions. Prefer "why" over "what" where non-obvious. Do not comment out code; remove or guard behind a feature flag.

---

## Before go-live / open source

- Run full test suite and fix any new failures or flakiness.
- Ensure no secrets or internal URLs in code or committed config; use env and `docs/guides/setup.md` for required vars.
- Confirm health endpoint exposes `tagline` and full health checks Orpheus (and optionally LLM/S3) as documented.
- Review `docs/guides/security.md` and apply the checklist (headers, rate limits, auth, logging).
- Keep README and docs accurate: service table, ports (10001–10099 block), and "Stream first, then MCP" messaging.
- When adding dependencies, update `pyproject.toml` and any Docker/CI that installs them.

---

## Quick reference

| Area        | Location              | Tests / Docs              |
|------------|------------------------|----------------------------|
| Config     | `app/config.py`        | `tests/test_config.py`     |
| Health     | `app/api/routes/health.py` | `tests/test_health.py`  |
| Intent     | `app/core/intent*.py`  | `tests/test_intent*.py`    |
| Pipeline   | `app/core/pipeline.py` | `tests/test_pipeline.py`   |
| Executor   | `app/core/executor.py` | `tests/test_executor.py`   |
| RAG        | `app/services/rag.py`  | `tests/test_rag.py`        |
| MCP        | `app/mcp/`, routes     | `tests/test_mcp.py`        |
| Auth       | `app/auth/`            | `tests/test_auth*.py`      |
| DB         | `app/db/`              | `tests/test_database.py`   |
| Docs index | —                     | `docs/README.md`           |
| Mypy       | `pyproject.toml` [tool.mypy] | `mypy app/ tests/` (CI + pre-commit) |
