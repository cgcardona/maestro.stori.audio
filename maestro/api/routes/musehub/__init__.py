"""Muse Hub route package.

Auto-discovers and registers all sub-routers under the shared ``/musehub``
prefix. Registered in ``maestro.main`` as:

    app.include_router(musehub.router, prefix="/api/v1", tags=["musehub"])

**Agent instruction — DO NOT EDIT THIS FILE.**
To add a new endpoint group, create a new module in this package that
exposes a ``router = APIRouter(...)`` attribute. It will be picked up
automatically on the next server start. No changes to this file are needed.

Registration order:
- ``analysis.harmony_router`` is registered before ``analysis.router`` so
  the specific ``/analysis/{ref}/harmony`` path takes priority over the
  generic ``/{dimension}`` catch-all declared in ``analysis.router``.
- All other modules are registered alphabetically.
- ``repos`` is always last because it declares the ``/{owner}/{repo_slug}``
  wildcard route, which must not shadow any fixed-path routes.

Auth policy:
- Public repo GET endpoints use ``optional_token`` — unauthenticated
  access is allowed for public repos; private repos return 401.
- Write endpoints (POST/PUT/DELETE) always use ``require_valid_token``
  declared on the individual route handler.
"""
from __future__ import annotations

import importlib
import pkgutil
from pathlib import Path

from fastapi import APIRouter

from maestro.api.routes.musehub import analysis

router = APIRouter(prefix="/musehub")

_PACKAGE = "maestro.api.routes.musehub"
_HERE = [str(Path(__file__).parent)]

# harmony_router first: specific /analysis/{ref}/harmony must beat the
# generic /{dimension} catch-all declared in analysis.router.
router.include_router(analysis.harmony_router, tags=["Analysis"])

# Load every sibling module that exposes a `router` attribute, alphabetically.
# repos goes last to avoid shadowing fixed-path routes with its wildcard.
for _mod_info in sorted(
    pkgutil.iter_modules(_HERE),
    key=lambda m: (m.name == "repos", m.name),
):
    _mod = importlib.import_module(f"{_PACKAGE}.{_mod_info.name}")
    if hasattr(_mod, "router"):
        _tag = _mod_info.name.replace("_", " ").title()
        router.include_router(_mod.router, tags=[_tag])

__all__ = ["router"]
