/**
 * WaveSurfer — lightweight canvas-based waveform player.
 *
 * Vendored at /musehub/static/vendor/wavesurfer.min.js.
 * No external CDN dependency. No npm required.
 *
 * Provides a compatible subset of the WaveSurfer.js API:
 *   WaveSurfer.create(options) -> instance
 *   instance.load(url)
 *   instance.play() / .pause() / .playPause()
 *   instance.isPlaying() -> bool
 *   instance.seekTo(0.0–1.0)
 *   instance.getCurrentTime() / .getDuration()
 *   instance.setPlaybackRate(rate)
 *   instance.setVolume(0.0–1.0)
 *   instance.clearRegion()
 *   instance.on(event, handler)
 *   instance.destroy()
 *
 * Events: 'ready', 'play', 'pause', 'finish', 'timeupdate', 'audioprocess',
 *         'seek', 'error', 'region-update', 'region-clear'
 *
 * A/B loop: Shift+drag on the canvas sets the loop region.
 * Plain click/tap seeks to that position.
 *
 * Waveform: Drawn from pseudo-random peaks seeded by audio duration, which
 * produces a plausible visual fingerprint for any track. A full Web Audio API
 * decode pass could replace _generatePeaks() for true amplitude data.
 */
(function (global) {
  'use strict';

  var DEFAULT_OPTIONS = {
    waveColor: '#4a5568',
    progressColor: '#1f6feb',
    cursorColor: '#58a6ff',
    height: 80,
    barWidth: 2,
    barGap: 1,
    normalize: true,
    interact: true,
  };

  /** @constructor */
  function WaveSurfer(options) {
    this.options = Object.assign({}, DEFAULT_OPTIONS, options);
    this._listeners = {};
    this._audio = new Audio();
    this._audio.preload = 'auto';
    this._duration = 0;
    this._currentTime = 0;
    this._loopStart = null;
    this._loopEnd = null;
    this._peaks = null;
    this._isDragging = false;
    this._dragStartX = null;
    this._ready = false;

    this._container =
      typeof options.container === 'string'
        ? document.querySelector(options.container)
        : options.container;

    if (!this._container) {
      throw new Error('WaveSurfer: container not found');
    }

    this._canvas = document.createElement('canvas');
    this._canvas.style.cssText =
      'width:100%;height:' + this.options.height + 'px;cursor:pointer;display:block;';
    this._container.appendChild(this._canvas);

    this._bindAudio();
    this._bindCanvas();
    this._drawWaveform();
  }

  /* ── Event emitter ─────────────────────────────────────────────────── */

  WaveSurfer.prototype.on = function (event, handler) {
    if (!this._listeners[event]) this._listeners[event] = [];
    this._listeners[event].push(handler);
    return this;
  };

  WaveSurfer.prototype._emit = function (event, data) {
    var handlers = this._listeners[event];
    if (!handlers) return;
    for (var i = 0; i < handlers.length; i++) handlers[i](data);
  };

  /* ── Audio binding ─────────────────────────────────────────────────── */

  WaveSurfer.prototype._bindAudio = function () {
    var self = this;

    this._audio.addEventListener('loadedmetadata', function () {
      self._duration = self._audio.duration || 0;
      self._generatePeaks();
    });

    this._audio.addEventListener('canplay', function () {
      if (!self._ready) {
        self._ready = true;
        self._emit('ready');
      }
    });

    this._audio.addEventListener('play', function () {
      self._emit('play');
    });

    this._audio.addEventListener('pause', function () {
      self._emit('pause');
    });

    this._audio.addEventListener('timeupdate', function () {
      self._currentTime = self._audio.currentTime;
      if (
        self._loopStart !== null &&
        self._loopEnd !== null &&
        self._audio.currentTime >= self._loopEnd
      ) {
        self._audio.currentTime = self._loopStart;
      }
      self._emit('timeupdate', self._audio.currentTime);
      self._emit('audioprocess', self._audio.currentTime);
      self._drawWaveform();
    });

    this._audio.addEventListener('ended', function () {
      self._emit('finish');
      self._drawWaveform();
    });

    this._audio.addEventListener('error', function () {
      self._emit('error', 'Audio unavailable');
    });
  };

  /* ── Peak generation ───────────────────────────────────────────────── */

  WaveSurfer.prototype._generatePeaks = function () {
    var count = 256;
    var peaks = new Float32Array(count);
    /* Lehmer LCG seeded by duration for a stable, plausible fingerprint. */
    var seed = Math.round((this._duration || 1.0) * 1000) | 0;
    for (var i = 0; i < count; i++) {
      seed = ((seed * 1664525 + 1013904223) | 0) & 0x7fffffff;
      var r = (seed & 0xff) / 255.0;
      var env = Math.sin((Math.PI * i) / count);
      peaks[i] = 0.1 + r * 0.75 * (0.25 + 0.75 * env);
    }
    /* Normalize to [0, 1]. */
    var max = 0;
    for (var j = 0; j < count; j++) if (peaks[j] > max) max = peaks[j];
    if (max > 0) for (var k = 0; k < count; k++) peaks[k] /= max;
    this._peaks = peaks;
    this._drawWaveform();
  };

  /* ── Canvas interaction ────────────────────────────────────────────── */

  WaveSurfer.prototype._bindCanvas = function () {
    if (!this.options.interact) return;
    var self = this;
    var canvas = this._canvas;

    function xFraction(e) {
      var rect = canvas.getBoundingClientRect();
      return Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
    }

    canvas.addEventListener('mousedown', function (e) {
      if (!self._duration) return;
      if (e.shiftKey) {
        self._dragStartX = xFraction(e);
        self._isDragging = true;
      } else {
        var f = xFraction(e);
        self._audio.currentTime = f * self._duration;
        self._emit('seek', f);
        self._drawWaveform();
      }
    });

    canvas.addEventListener('mousemove', function (e) {
      if (!self._isDragging || self._dragStartX === null) return;
      var f = xFraction(e);
      var lo = Math.min(self._dragStartX, f);
      var hi = Math.max(self._dragStartX, f);
      self._loopStart = lo * self._duration;
      self._loopEnd = hi * self._duration;
      self._drawWaveform();
    });

    canvas.addEventListener('mouseup', function (e) {
      if (self._isDragging) {
        self._isDragging = false;
        self._emit('region-update', {
          start: self._loopStart,
          end: self._loopEnd,
        });
      }
    });

    canvas.addEventListener(
      'touchstart',
      function (e) {
        if (!self._duration) return;
        e.preventDefault();
        var touch = e.touches[0];
        var rect = canvas.getBoundingClientRect();
        var f = Math.max(
          0,
          Math.min(1, (touch.clientX - rect.left) / rect.width)
        );
        self._audio.currentTime = f * self._duration;
        self._emit('seek', f);
        self._drawWaveform();
      },
      { passive: false }
    );

    if (typeof ResizeObserver !== 'undefined') {
      new ResizeObserver(function () {
        self._drawWaveform();
      }).observe(canvas);
    }
  };

  /* ── Waveform renderer ─────────────────────────────────────────────── */

  WaveSurfer.prototype._drawWaveform = function () {
    var canvas = this._canvas;
    var W = canvas.offsetWidth || 400;
    var H = this.options.height;
    if (canvas.width !== W) canvas.width = W;
    if (canvas.height !== H) canvas.height = H;

    var ctx = canvas.getContext('2d');
    if (!ctx) return;

    var progress =
      this._duration > 0 ? this._currentTime / this._duration : 0;

    /* Background */
    ctx.fillStyle = '#0d1117';
    ctx.fillRect(0, 0, W, H);

    /* A/B loop region overlay */
    if (
      this._loopStart !== null &&
      this._loopEnd !== null &&
      this._duration > 0
    ) {
      var loS = (this._loopStart / this._duration) * W;
      var loE = (this._loopEnd / this._duration) * W;
      ctx.fillStyle = 'rgba(31,111,235,0.18)';
      ctx.fillRect(loS, 0, loE - loS, H);
      ctx.strokeStyle = 'rgba(88,166,255,0.5)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(loS, 0);
      ctx.lineTo(loS, H);
      ctx.moveTo(loE, 0);
      ctx.lineTo(loE, H);
      ctx.stroke();
    }

    var peaks = this._peaks;
    if (!peaks) {
      /* Placeholder skeleton bars before audio loads */
      var step = W / 60;
      for (var xi = 0; xi < 60; xi++) {
        var ph = H * 0.12 * (0.4 + 0.6 * Math.abs(Math.sin(xi * 0.35)));
        ctx.fillStyle = '#21262d';
        ctx.fillRect(xi * step, (H - ph) / 2, step * 0.55, ph);
      }
      return;
    }

    /* Bar chart */
    var barW = this.options.barWidth;
    var barGap = this.options.barGap;
    var unit = barW + barGap;
    var numBars = Math.floor(W / unit);

    for (var i = 0; i < numBars; i++) {
      var px = i * unit;
      var pidx = Math.floor((i / numBars) * peaks.length);
      var amp = peaks[pidx];
      var bh = Math.max(2, amp * H * 0.88);
      var by = (H - bh) / 2;
      ctx.fillStyle = px / W < progress
        ? this.options.progressColor
        : this.options.waveColor;
      ctx.fillRect(px, by, barW, bh);
    }

    /* Playhead cursor */
    var cx = progress * W;
    ctx.fillStyle = this.options.cursorColor;
    ctx.fillRect(cx - 1, 0, 2, H);
  };

  /* ── Public API ────────────────────────────────────────────────────── */

  WaveSurfer.prototype.load = function (url) {
    this._ready = false;
    this._peaks = null;
    this._currentTime = 0;
    this._duration = 0;
    this._loopStart = null;
    this._loopEnd = null;
    this._audio.src = url;
    this._audio.load();
    this._drawWaveform();
  };

  WaveSurfer.prototype.play = function () {
    return this._audio.play();
  };

  WaveSurfer.prototype.pause = function () {
    this._audio.pause();
  };

  WaveSurfer.prototype.playPause = function () {
    if (this._audio.paused) return this.play();
    this.pause();
  };

  WaveSurfer.prototype.isPlaying = function () {
    return !this._audio.paused && !this._audio.ended;
  };

  WaveSurfer.prototype.seekTo = function (progress) {
    if (this._duration > 0) {
      this._audio.currentTime = Math.max(0, Math.min(1, progress)) * this._duration;
    }
  };

  WaveSurfer.prototype.getCurrentTime = function () {
    return this._audio.currentTime;
  };

  WaveSurfer.prototype.getDuration = function () {
    return this._audio.duration || 0;
  };

  WaveSurfer.prototype.setPlaybackRate = function (rate) {
    this._audio.playbackRate = rate;
  };

  WaveSurfer.prototype.setVolume = function (vol) {
    this._audio.volume = Math.max(0, Math.min(1, vol));
  };

  WaveSurfer.prototype.clearRegion = function () {
    this._loopStart = null;
    this._loopEnd = null;
    this._emit('region-clear');
    this._drawWaveform();
  };

  WaveSurfer.prototype.destroy = function () {
    this._audio.pause();
    this._audio.src = '';
    if (this._canvas.parentNode) {
      this._canvas.parentNode.removeChild(this._canvas);
    }
    this._listeners = {};
  };

  /* ── Factory ───────────────────────────────────────────────────────── */

  WaveSurfer.create = function (options) {
    return new WaveSurfer(options);
  };

  global.WaveSurfer = WaveSurfer;
})(typeof window !== 'undefined' ? window : this);
