{% extends "musehub/base.html" %}

{% block title %}Commit Graph{% endblock %}
{% block breadcrumb %}
  <a href="/musehub/ui/{{ owner }}/{{ repo_slug }}">{{ owner }}/{{ repo_slug }}</a> / graph
{% endblock %}
{% block repo_nav %}{% include "musehub/partials/repo_nav.html" %}{% endblock %}

{% block page_data %}
const repoId = {{ repo_id | tojson }};
const base   = {{ base_url | tojson }};
{% endblock %}

{% block page_script %}
{% raw %}
const BRANCH_COLORS = [
  '#58a6ff', '#3fb950', '#f0883e', '#bc8cff', '#ff7b72',
  '#79c0ff', '#56d364', '#ffa657', '#d2a8ff', '#ff9492',
];
const _branchColorCache = {};
function branchColor(name) {
  if (_branchColorCache[name]) return _branchColorCache[name];
  let h = 0;
  for (let i = 0; i < name.length; i++) h = (h * 31 + name.charCodeAt(i)) | 0;
  const c = BRANCH_COLORS[Math.abs(h) % BRANCH_COLORS.length];
  _branchColorCache[name] = c;
  return c;
}

const NODE_R   = 10;
const ROW_H    = 48;
const COL_W    = 32;
const PAD_LEFT = 20;
const PAD_TOP  = 20;

// Session teal ring color — distinct from HEAD orange and branch colours.
const SESSION_RING_COLOR = '#2dd4bf';

function layoutNodes(nodes) {
  const colMap = {};
  let nextCol = 0;
  const pos = {};
  nodes.forEach((n, row) => {
    if (colMap[n.branch] === undefined) colMap[n.branch] = nextCol++;
    pos[n.commitId] = { col: colMap[n.branch], row };
  });
  const maxCol = nextCol;
  return { pos, maxCol };
}

// Build a map of commitId → { intent, sessionId } from sessions data.
// A commit may appear in multiple sessions; we keep the most-recently-started one.
function buildSessionMap(sessions) {
  const map = {};
  const sorted = [...sessions].sort((a, b) =>
    new Date(b.startedAt).getTime() - new Date(a.startedAt).getTime()
  );
  sorted.forEach(s => {
    (s.commits || []).forEach(cid => {
      if (!map[cid]) {
        map[cid] = { intent: s.intent || '', sessionId: s.sessionId };
      }
    });
  });
  return map;
}

// Batch-fetch reaction counts for an array of commitIds.
// Returns a map of commitId → { topEmoji, totalCount }.
async function fetchReactions(repoId, commitIds) {
  const results = {};
  await Promise.all(commitIds.map(async cid => {
    try {
      const data = await apiFetch(
        `/repos/${repoId}/reactions?target_type=commit&target_id=${encodeURIComponent(cid)}`
      );
      const list = Array.isArray(data) ? data : [];
      const total = list.reduce((s, r) => s + (r.count || 0), 0);
      const top = list.sort((a, b) => (b.count || 0) - (a.count || 0))[0];
      results[cid] = { topEmoji: top ? top.emoji : null, totalCount: total };
    } catch (_) {
      results[cid] = { topEmoji: null, totalCount: 0 };
    }
  }));
  return results;
}

function renderGraph(data, sessionMap, reactionMap) {
  const { nodes, edges, headCommitId } = data;
  if (!nodes.length) {
    document.getElementById('content').innerHTML =
      '<div class="card"><p class="loading">No commits yet -- nothing to graph.</p></div>';
    return;
  }

  const { pos, maxCol } = layoutNodes(nodes);
  const svgW = PAD_LEFT * 2 + maxCol * COL_W + 400;
  const svgH = PAD_TOP  * 2 + nodes.length * ROW_H;

  const nodeMap = {};
  nodes.forEach(n => { nodeMap[n.commitId] = n; });

  let edgePaths = '';
  edges.forEach(e => {
    const src = pos[e.source];
    const tgt = pos[e.target];
    if (!src || !tgt) return;
    const x1 = PAD_LEFT + src.col * COL_W;
    const y1 = PAD_TOP  + src.row * ROW_H;
    const x2 = PAD_LEFT + tgt.col * COL_W;
    const y2 = PAD_TOP  + tgt.row * ROW_H;
    const cx = x1; const cy = y2;
    const color = branchColor(nodeMap[e.source] ? nodeMap[e.source].branch : 'main');
    edgePaths += `<path d="M${x1},${y1} C${cx},${cy} ${cx},${cy} ${x2},${y2}"
      stroke="${color}" stroke-width="2" fill="none" opacity="0.6"/>`;
  });

  let nodeCircles = '';
  let nodeLabels = '';
  nodes.forEach(n => {
    const p = pos[n.commitId];
    const cx = PAD_LEFT + p.col * COL_W;
    const cy = PAD_TOP  + p.row  * ROW_H;
    const color = branchColor(n.branch);
    const isHead = n.commitId === headCommitId || n.isHead;
    const isMerge = (n.parentIds || []).length > 1;
    const inSession = Boolean(sessionMap[n.commitId]);

    // Session teal ring — rendered behind the node so it frames it cleanly.
    if (inSession) {
      nodeCircles += `<circle cx="${cx}" cy="${cy}" r="${NODE_R + 5}"
        fill="none" stroke="${SESSION_RING_COLOR}" stroke-width="2.5" opacity="0.85"/>`;
    }
    if (isHead) {
      nodeCircles += `<circle cx="${cx}" cy="${cy}" r="${NODE_R + (inSession ? 9 : 4)}"
        fill="none" stroke="#f0883e" stroke-width="2" opacity="0.9"/>`;
    }
    if (isMerge) {
      nodeCircles += `<rect x="${cx - NODE_R * 0.8}" y="${cy - NODE_R * 0.8}"
        width="${NODE_R * 1.6}" height="${NODE_R * 1.6}"
        fill="${color}" stroke="#0d1117" stroke-width="1.5"
        transform="rotate(45 ${cx} ${cy})"
        class="dag-node" data-id="${n.commitId}" style="cursor:pointer"/>`;
    } else {
      nodeCircles += `<circle cx="${cx}" cy="${cy}" r="${NODE_R}"
        fill="${color}" stroke="#0d1117" stroke-width="1.5"
        class="dag-node" data-id="${n.commitId}" style="cursor:pointer"/>`;
    }

    const msg = n.message.length > 55 ? n.message.substring(0,52) + '...' : n.message;
    const labelX = PAD_LEFT + maxCol * COL_W + 12;
    nodeLabels += `<text x="${labelX}" y="${cy + 4}" font-size="13"
      fill="#c9d1d9" style="cursor:pointer" class="dag-node" data-id="${n.commitId}">
      <tspan font-family="monospace" fill="#58a6ff">${n.commitId.substring(0,7)}</tspan>
      <tspan dx="8">${escHtml(msg)}</tspan>
    </text>`;

    let badgeX = labelX;
    (n.branchLabels || []).forEach(lbl => {
      const bw = lbl.length * 7 + 12;
      nodeLabels += `<rect x="${badgeX - 4}" y="${cy - 20}" width="${bw}" height="14"
        rx="7" fill="${branchColor(lbl)}" opacity="0.25"/>
      <text x="${badgeX}" y="${cy - 9}" font-size="11" fill="${branchColor(lbl)}">${escHtml(lbl)}</text>`;
      badgeX += bw + 6;
    });
  });

  const svgContent = `
    <defs>
      <marker id="arrow" markerWidth="6" markerHeight="6" refX="3" refY="3"
        orient="auto" markerUnits="strokeWidth">
        <path d="M0,0 L6,3 L0,6 z" fill="#8b949e"/>
      </marker>
    </defs>
    ${edgePaths}
    ${nodeCircles}
    ${nodeLabels}`;

  const branchesInGraph = [...new Set(nodes.map(n => n.branch))];
  const legendItems = branchesInGraph.map(b =>
    `<span style="display:inline-flex;align-items:center;gap:6px;margin-right:16px">
      <svg width="12" height="12"><circle cx="6" cy="6" r="5" fill="${branchColor(b)}"/></svg>
      <span style="font-size:13px;color:#c9d1d9">${escHtml(b)}</span>
    </span>`
  ).join('');

  document.getElementById('content').innerHTML = `
    <div style="margin-bottom:12px;display:flex;align-items:center;gap:12px;flex-wrap:wrap">
      <a href="${base}">&larr; Back to repo</a>
      <span style="color:#8b949e;font-size:13px">${nodes.length} commit${nodes.length!==1?'s':''} &bull; scroll to zoom &bull; drag to pan</span>
    </div>
    <div class="card" style="padding:0;overflow:hidden">
      <div style="padding:12px 16px;border-bottom:1px solid #30363d;display:flex;align-items:center;flex-wrap:wrap;gap:4px">
        <span style="font-size:12px;color:#8b949e;margin-right:8px">Branches:</span>
        ${legendItems}
        <span style="font-size:12px;color:#8b949e;margin-left:auto">&#9830; = merge commit</span>
        <span style="font-size:12px;color:#f0883e;margin-left:12px">&#9711; = HEAD</span>
        <span style="font-size:12px;color:${SESSION_RING_COLOR};margin-left:12px">&#9675; = session</span>
      </div>
      <div id="dag-viewport" style="overflow:hidden;position:relative;height:520px;background:#0d1117;cursor:grab">
        <svg id="dag-svg" width="${svgW}" height="${svgH}" style="position:absolute;top:0;left:0">
          <g id="dag-g" transform="translate(0,0) scale(1)">
            ${svgContent}
          </g>
        </svg>
      </div>
    </div>
    <div id="dag-popover" style="display:none;position:fixed;z-index:1000;background:#161b22;
      border:1px solid #30363d;border-radius:8px;padding:12px 16px;min-width:280px;max-width:400px;
      box-shadow:0 8px 32px rgba(0,0,0,0.6);pointer-events:none">
      <div style="font-family:monospace;font-size:13px;color:#58a6ff;margin-bottom:6px" id="pop-sha"></div>
      <div style="font-size:13px;color:#e6edf3;margin-bottom:6px;word-break:break-word" id="pop-msg"></div>
      <div style="font-size:12px;color:#8b949e" id="pop-meta"></div>
      <div style="font-size:12px;color:${SESSION_RING_COLOR};margin-top:6px;display:none" id="pop-session"></div>
      <div style="font-size:12px;color:#8b949e;margin-top:4px;display:none" id="pop-reactions"></div>
    </div>`;

  const viewport = document.getElementById('dag-viewport');
  const g = document.getElementById('dag-g');
  let scale = 1, tx = 0, ty = 0;
  let dragging = false, dragX = 0, dragY = 0;

  function applyTransform() {
    g.setAttribute('transform', `translate(${tx},${ty}) scale(${scale})`);
  }

  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const rect = viewport.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const delta = e.deltaY > 0 ? 0.85 : 1.15;
    const newScale = Math.max(0.2, Math.min(4, scale * delta));
    tx = mx - (mx - tx) * (newScale / scale);
    ty = my - (my - ty) * (newScale / scale);
    scale = newScale;
    applyTransform();
  }, { passive: false });

  viewport.addEventListener('mousedown', e => {
    dragging = true; dragX = e.clientX; dragY = e.clientY;
    viewport.style.cursor = 'grabbing';
  });
  window.addEventListener('mouseup', () => {
    dragging = false;
    if (viewport) viewport.style.cursor = 'grab';
  });
  window.addEventListener('mousemove', e => {
    if (!dragging) return;
    tx += e.clientX - dragX; ty += e.clientY - dragY;
    dragX = e.clientX; dragY = e.clientY;
    applyTransform();
  });

  const popover = document.getElementById('dag-popover');
  const popSession = document.getElementById('pop-session');
  const popReactions = document.getElementById('pop-reactions');
  const svgEl = document.getElementById('dag-svg');
  svgEl.addEventListener('mousemove', e => {
    const target = e.target.closest('.dag-node');
    if (!target) { popover.style.display = 'none'; return; }
    const cid = target.getAttribute('data-id');
    const node = nodeMap[cid];
    if (!node) { popover.style.display = 'none'; return; }
    document.getElementById('pop-sha').textContent = node.commitId;
    document.getElementById('pop-msg').textContent = node.message;
    document.getElementById('pop-meta').innerHTML =
      escHtml(node.author) + ' &bull; ' + fmtDate(node.timestamp) +
      ' &bull; ' + escHtml(node.branch);

    // Session context
    const sess = sessionMap[cid];
    if (sess && sess.intent) {
      popSession.textContent = '\u25cb Session: ' + sess.intent;
      popSession.style.display = 'block';
    } else {
      popSession.style.display = 'none';
    }

    // Reaction summary
    const rxn = reactionMap[cid];
    if (rxn && rxn.totalCount > 0) {
      const parts = [];
      if (rxn.topEmoji) parts.push(rxn.topEmoji);
      parts.push(rxn.totalCount + ' reaction' + (rxn.totalCount !== 1 ? 's' : ''));
      popReactions.textContent = parts.join(' ');
      popReactions.style.display = 'block';
    } else {
      popReactions.style.display = 'none';
    }

    popover.style.display = 'block';
    const vw = window.innerWidth, vh = window.innerHeight;
    let px = e.clientX + 16, py = e.clientY + 16;
    if (px + 420 > vw) px = e.clientX - 420;
    if (py + 160 > vh) py = e.clientY - 160;
    popover.style.left = px + 'px';
    popover.style.top  = py + 'px';
  });
  svgEl.addEventListener('mouseleave', () => { popover.style.display = 'none'; });

  svgEl.addEventListener('click', e => {
    const target = e.target.closest('.dag-node');
    if (!target) return;
    const cid = target.getAttribute('data-id');
    if (cid) window.location.href = base + '/commits/' + cid;
  });
}

async function load() {
  initRepoNav(repoId);
  try {
    // Fetch DAG, sessions, and reactions in parallel.
    // Reactions are batch-fetched for all commit IDs to avoid N+1 queries.
    const [dagData, sessionsData] = await Promise.all([
      apiFetch('/repos/' + repoId + '/dag'),
      apiFetch('/repos/' + repoId + '/sessions?limit=200').catch(() => ({ sessions: [] })),
    ]);

    const sessions = (sessionsData.sessions || []);
    const sessionMap = buildSessionMap(sessions);
    const commitIds = (dagData.nodes || []).map(n => n.commitId);
    const reactionMap = commitIds.length
      ? await fetchReactions(repoId, commitIds)
      : {};

    renderGraph(dagData, sessionMap, reactionMap);
  } catch(e) {
    if (e.message !== 'auth')
      document.getElementById('content').innerHTML =
        '<p class="error">&#10005; ' + escHtml(e.message) + '</p>';
  }
}

load();
{% endraw %}
{% endblock %}
