{% extends "musehub/base.html" %}

{% block title %}Activity Feed{% endblock %}
{% block breadcrumb %}Activity Feed{% endblock %}

{% block page_script %}
{% raw %}
/**
 * Deterministic HSL hue from an actor string â€” stable, visually distinct
 * colour per user without any stored data.
 */
function actorHsl(actor) {
  let hash = 0;
  for (let i = 0; i < actor.length; i++) {
    hash = actor.charCodeAt(i) + ((hash << 5) - hash);
  }
  return 'hsl(' + (Math.abs(hash) % 360) + ',50%,38%)';
}

/**
 * Render a 32 Ã— 32 avatar circle for the actor: initial on an HSL background.
 */
function actorAvatar(actor) {
  const bg      = actorHsl(actor);
  const initial = escHtml((actor || '?').charAt(0).toUpperCase());
  return `<div class="comment-avatar" style="background:${bg};color:#e6edf3;font-weight:700;font-size:14px;border:none">${initial}</div>`;
}

/**
 * Build a profile-page link for the actor.
 */
function actorLink(actor) {
  return `<a href="/musehub/ui/users/${encodeURIComponent(actor)}" style="color:var(--text-primary);font-weight:600">${escHtml(actor)}</a>`;
}

/**
 * Build a repo link when repo_id is present.
 * repo_id is expected to be "owner/slug".
 */
function repoLink(repoId) {
  if (!repoId) return '';
  const parts = repoId.split('/');
  const label = parts.length >= 2 ? escHtml(parts[1]) : escHtml(repoId);
  return `<a href="/musehub/ui/${encodeURIComponent(repoId)}" style="color:var(--color-accent)">${label}</a>`;
}

const EVENT_META = {
  comment:      { icon: 'ðŸ—¨ï¸',  sentence: (a, r) => `${actorLink(a)} commented on ${repoLink(r)}` },
  mention:      { icon: 'ðŸ’¬',  sentence: (a, r) => `${actorLink(a)} mentioned you in ${repoLink(r)}` },
  pr_opened:    { icon: 'ðŸ”€',  sentence: (a, r) => `${actorLink(a)} opened a PR in ${repoLink(r)}` },
  pr_merged:    { icon: 'âœ…',  sentence: (a, r) => `${actorLink(a)} merged a PR in ${repoLink(r)}` },
  issue_opened: { icon: 'ðŸ›',  sentence: (a, r) => `${actorLink(a)} opened an issue in ${repoLink(r)}` },
  issue_closed: { icon: 'âœ”ï¸', sentence: (a, r) => `${actorLink(a)} closed an issue in ${repoLink(r)}` },
  new_commit:   { icon: 'ðŸŽµ',  sentence: (a, r) => `${actorLink(a)} committed to ${repoLink(r)}` },
  new_follower: { icon: 'ðŸ‘¤',  sentence: (a, _) => `${actorLink(a)} followed you` },
};

/**
 * Render a single notification as a rich event card.
 *
 * Unread cards include a "Mark read" button (âœ“) that calls
 * POST /notifications/{notif_id}/read and applies the read style in-place
 * without a full page reload.
 */
function eventCard(item) {
  const meta      = EVENT_META[item.event_type] || { icon: 'â€¢', sentence: (a) => actorLink(a) };
  const icon      = meta.icon;
  const sentence  = meta.sentence(item.actor, item.repo_id || '');
  const timestamp = fmtRelative(item.created_at);
  const isUnread  = !item.is_read;

  const unreadStyle = isUnread
    ? 'border-left:3px solid var(--color-accent);padding-left:calc(var(--space-3) - 3px);'
    : 'border-left:3px solid transparent;padding-left:calc(var(--space-3) - 3px);opacity:0.75;';

  const markReadBtn = isUnread
    ? `<button
         class="mark-read-btn"
         data-notif-id="${escHtml(item.notif_id)}"
         onclick="markOneRead(this)"
         title="Mark as read"
         style="background:none;border:1px solid var(--border-color);border-radius:50%;width:22px;height:22px;cursor:pointer;color:var(--text-muted);font-size:12px;line-height:1;display:inline-flex;align-items:center;justify-content:center;flex-shrink:0;margin-left:var(--space-2)"
       >&#10003;</button>`
    : '';

  return `
    <div class="comment-item" data-notif-id="${escHtml(item.notif_id)}" style="${unreadStyle}">
      ${actorAvatar(item.actor)}
      <div class="comment-body" style="flex:1;min-width:0">
        <div class="comment-meta" style="display:flex;align-items:center;gap:var(--space-2);flex-wrap:wrap">
          <span style="font-size:16px;line-height:1">${icon}</span>
          <span>${sentence}</span>
          <span style="margin-left:auto;white-space:nowrap;display:flex;align-items:center;gap:var(--space-2)">
            ${escHtml(timestamp)}
            ${markReadBtn}
          </span>
        </div>
        ${isUnread ? '<div class="unread-dot" style="width:6px;height:6px;border-radius:50%;background:var(--color-accent);display:inline-block;margin-top:var(--space-1)"></div>' : ''}
      </div>
    </div>`;
}

/**
 * Mark a single notification as read via POST /notifications/{notif_id}/read.
 * Updates the card styling and nav badge count in-place on success.
 */
async function markOneRead(btn) {
  const notifId = btn.dataset.notifId;
  if (!notifId) return;
  try {
    await apiFetch('/notifications/' + encodeURIComponent(notifId) + '/read', { method: 'POST' });
    const card = document.querySelector('.comment-item[data-notif-id="' + CSS.escape(notifId) + '"]');
    if (card) {
      card.style.borderLeft = '3px solid transparent';
      card.style.opacity    = '0.75';
      const dot = card.querySelector('.unread-dot');
      if (dot) dot.remove();
    }
    btn.remove();
    decrementNavBadge();
  } catch (e) {
    if (e.message !== 'auth') btn.style.color = 'var(--color-danger)';
  }
}

/**
 * Mark all notifications as read via POST /notifications/read-all.
 * Applies read styling to every card and resets the nav badge to 0.
 */
async function markAllRead() {
  const markAllBtn = document.getElementById('mark-all-read-btn');
  if (markAllBtn) markAllBtn.disabled = true;
  try {
    await apiFetch('/notifications/read-all', { method: 'POST' });
    document.querySelectorAll('.comment-item').forEach(card => {
      card.style.borderLeft = '3px solid transparent';
      card.style.opacity    = '0.75';
      const dot = card.querySelector('.unread-dot');
      if (dot) dot.remove();
      const btn = card.querySelector('.mark-read-btn');
      if (btn) btn.remove();
    });
    const badge = document.getElementById('nav-notif-badge');
    if (badge) badge.style.display = 'none';
    if (markAllBtn) markAllBtn.remove();
  } catch (e) {
    if (markAllBtn) markAllBtn.disabled = false;
    if (e.message !== 'auth') {
      const err = document.getElementById('feed-error');
      if (err) err.textContent = 'Could not mark all as read: ' + e.message;
    }
  }
}

/**
 * Decrement the nav badge count by 1; hide it when it reaches 0.
 */
function decrementNavBadge() {
  const badge = document.getElementById('nav-notif-badge');
  if (!badge) return;
  const current = parseInt(badge.textContent, 10);
  if (isNaN(current) || current <= 1) {
    badge.style.display = 'none';
  } else {
    badge.textContent = String(current - 1);
  }
}

async function load() {
  try {
    const items = (await apiFetch('/feed?limit=50')) || [];

    if (items.length === 0) {
      document.getElementById('content').innerHTML = `
        <div class="empty-state">
          <div class="empty-icon">&#127926;</div>
          <p class="empty-title">Your feed is empty</p>
          <p class="empty-desc">Follow musicians and watch repos to see their activity here.</p>
          <a href="/musehub/ui/explore" class="btn btn-primary">Explore repos</a>
        </div>`;
      return;
    }

    const hasUnread = items.some(item => !item.is_read);
    const markAllHtml = hasUnread && getToken()
      ? `<button
           id="mark-all-read-btn"
           onclick="markAllRead()"
           class="btn btn-secondary"
           style="font-size:12px;padding:4px 10px"
         >&#10003; Mark all as read</button>`
      : '';

    document.getElementById('content').innerHTML = `
      <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:var(--space-4)">
        <h1 style="margin:0">Activity Feed</h1>
        ${markAllHtml}
      </div>
      <p id="feed-error" style="color:var(--color-danger);font-size:13px"></p>
      <div class="card" style="padding:0">
        ${items.map(eventCard).join('')}
      </div>`;
  } catch (e) {
    if (e.message !== 'auth')
      document.getElementById('content').innerHTML = '<p class="error">&#10005; ' + escHtml(e.message) + '</p>';
  }
}

load();
{% endraw %}
{% endblock %}
