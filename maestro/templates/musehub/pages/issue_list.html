{% extends "musehub/base.html" %}

{% block title %}Issues{% endblock %}
{% block breadcrumb %}
  <a href="/musehub/ui/{{ owner }}/{{ repo_slug }}">{{ owner }}/{{ repo_slug }}</a> / issues
{% endblock %}
{% block repo_nav %}{% include "musehub/partials/repo_nav.html" %}{% endblock %}

{% block page_data %}
const repoId = {{ repo_id | tojson }};
const base   = {{ base_url | tojson }};
{% endblock %}

{% block page_script %}
{% raw %}
// ── State ──────────────────────────────────────────────────────────────────
let allIssues   = [];     // full list from API (state-filtered only)
let activeLabel = null;   // label string currently filtering, or null
let activeSort  = 'newest'; // 'newest' | 'oldest' | 'most-commented'
let commentCounts = {};   // { issue_id: count } — populated on demand

// ── Body preview ───────────────────────────────────────────────────────────
function bodyPreview(body) {
  if (!body) return '';
  const first = body.split('\n')[0].trim();
  return first.length > 100 ? first.slice(0, 97) + '…' : first;
}

// ── Sorting ────────────────────────────────────────────────────────────────
function sortedIssues(issues) {
  const copy = [...issues];
  if (activeSort === 'oldest') {
    copy.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
  } else if (activeSort === 'most-commented') {
    copy.sort((a, b) => (commentCounts[b.issueId] || 0) - (commentCounts[a.issueId] || 0));
  } else {
    // newest (default)
    copy.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
  }
  return copy;
}

// ── Label filter ───────────────────────────────────────────────────────────
function setLabelFilter(label) {
  activeLabel = (activeLabel === label) ? null : label;
  renderRows();
}

// ── Render rows ────────────────────────────────────────────────────────────
function renderRows() {
  let issues = allIssues;
  if (activeLabel) {
    issues = issues.filter(i => (i.labels || []).includes(activeLabel));
  }
  issues = sortedIssues(issues);

  const container = document.getElementById('issue-rows');
  if (!container) return;

  if (issues.length === 0) {
    container.innerHTML = activeLabel
      ? `<p class="loading">No issues with label "<strong>${escHtml(activeLabel)}</strong>". <a href="#" onclick="setLabelFilter(null);return false;">Clear filter</a></p>`
      : '<p class="loading">No issues found.</p>';
    return;
  }

  container.innerHTML = issues.map(i => {
    const preview = bodyPreview(i.body);
    const labels  = (i.labels || []);
    const commentCount = commentCounts[i.issueId];
    const commentBadge = commentCount != null
      ? `<span style="font-size:11px;color:#8b949e;margin-left:auto">&#128172; ${commentCount}</span>`
      : '';
    return `
      <div class="issue-row" data-issue-id="${i.issueId}">
        <span class="badge badge-${i.state}">#${i.number}</span>
        <div style="flex:1;min-width:0">
          <a href="${base}/issues/${i.number}">${escHtml(i.title)}</a>
          ${preview ? `<div class="issue-preview">${escHtml(preview)}</div>` : ''}
          <div style="display:flex;align-items:center;gap:var(--space-2);flex-wrap:wrap;margin-top:4px">
            ${labels.map(l => `<span class="label label-pill${activeLabel === l ? ' label-active' : ''}" onclick="setLabelFilter(${JSON.stringify(l)})" style="cursor:pointer" title="Filter by ${escHtml(l)}">${escHtml(l)}</span>`).join('')}
            <span style="font-size:11px;color:#8b949e">Opened ${fmtDate(i.createdAt)}</span>
            ${commentBadge}
          </div>
        </div>
        <span class="badge badge-${i.state}">${i.state}</span>
      </div>`;
  }).join('');
}

// ── Load comment counts (called when sort=most-commented) ──────────────────
async function loadCommentCounts(issues) {
  await Promise.all(issues.map(async i => {
    try {
      const rows = await apiFetch('/repos/' + repoId + '/comments?target_type=issue&target_id=' + encodeURIComponent(i.issueId));
      commentCounts[i.issueId] = Array.isArray(rows) ? rows.length : 0;
    } catch (_) {
      commentCounts[i.issueId] = 0;
    }
  }));
}

// ── Sort control handler ───────────────────────────────────────────────────
async function changeSort(value) {
  activeSort = value;
  if (activeSort === 'most-commented' && allIssues.length > 0) {
    // fetch counts only on first request — cache in commentCounts
    const uncounted = allIssues.filter(i => commentCounts[i.issueId] == null);
    if (uncounted.length > 0) {
      document.getElementById('sort-loading').style.display = '';
      await loadCommentCounts(uncounted);
      document.getElementById('sort-loading').style.display = 'none';
    }
  }
  renderRows();
}

// ── Main load ──────────────────────────────────────────────────────────────
async function load(state) {
  initRepoNav(repoId);
  try {
    // Fetch open + closed counts in parallel
    const [openData, closedData] = await Promise.all([
      apiFetch('/repos/' + repoId + '/issues?state=open'),
      apiFetch('/repos/' + repoId + '/issues?state=closed'),
    ]);

    const openCount   = (openData.issues   || []).length;
    const closedCount = (closedData.issues  || []).length;

    allIssues   = state === 'closed' ? (closedData.issues || []) : (openData.issues || []);
    activeLabel = null;

    document.getElementById('content').innerHTML = `
      <div class="card">
        <div style="display:flex;align-items:center;gap:var(--space-3);margin-bottom:var(--space-3);flex-wrap:wrap">
          <h1 style="margin:0">Issues</h1>
          <div style="margin-left:auto;display:flex;gap:var(--space-2)">
            <button class="btn btn-secondary btn-sm" onclick="showCreateIssue()">
              + New Issue
            </button>
          </div>
        </div>

        <!-- Open / Closed tabs -->
        <div style="display:flex;gap:0;border-bottom:1px solid var(--color-border);margin-bottom:var(--space-3)">
          <button id="tab-open" class="tab-btn${state !== 'closed' ? ' tab-active' : ''}"
                  onclick="load('open')">
            &#9711; Open <span class="tab-count">${openCount}</span>
          </button>
          <button id="tab-closed" class="tab-btn${state === 'closed' ? ' tab-active' : ''}"
                  onclick="load('closed')">
            &#10003; Closed <span class="tab-count">${closedCount}</span>
          </button>
        </div>

        <!-- Sort + label-clear bar -->
        <div style="display:flex;align-items:center;gap:var(--space-3);margin-bottom:var(--space-3);flex-wrap:wrap">
          <span style="font-size:13px;color:#8b949e">Sort by:</span>
          <div style="display:flex;gap:var(--space-1)">
            <button class="btn btn-ghost btn-sm sort-btn${activeSort==='newest'?' sort-active':''}" onclick="changeSort('newest')">Newest</button>
            <button class="btn btn-ghost btn-sm sort-btn${activeSort==='oldest'?' sort-active':''}" onclick="changeSort('oldest')">Oldest</button>
            <button class="btn btn-ghost btn-sm sort-btn${activeSort==='most-commented'?' sort-active':''}" onclick="changeSort('most-commented')">Most commented</button>
          </div>
          <span id="sort-loading" style="display:none;font-size:12px;color:#8b949e">Loading…</span>
          <div id="label-filter-bar"></div>
        </div>

        <!-- Issue rows -->
        <div id="issue-rows"></div>

        ${openCount === 0 && closedCount === 0 ? `
          <div class="empty-state">
            <div class="empty-icon">&#128203;</div>
            <p class="empty-title">No issues yet</p>
            <p class="empty-desc">Found a musical problem or want to track something? Open an issue.</p>
            <button class="btn btn-primary" onclick="showCreateIssue()">Open first issue</button>
          </div>` : ''}
      </div>
      <div id="create-issue-panel" style="display:none">
        <div class="card" style="border-color:var(--color-accent)">
          <h2 style="margin-bottom:var(--space-3)">New Issue</h2>
          <div class="form-group" style="margin-bottom:var(--space-3)">
            <label class="form-label" for="issue-title">Title</label>
            <input id="issue-title" class="form-input" type="text" placeholder="Brief description of the issue…"/>
          </div>
          <div class="form-group" style="margin-bottom:var(--space-3)">
            <label class="form-label" for="issue-body">Description</label>
            <textarea id="issue-body" class="form-input" rows="5"
                      placeholder="Describe the musical problem or request…"
                      style="resize:vertical;width:100%"></textarea>
            <button class="btn btn-ghost btn-sm" style="margin-top:var(--space-2)"
                    onclick="suggestIssueBody()">
              &#129504; Suggest musical improvements
            </button>
          </div>
          <div style="display:flex;gap:var(--space-2)">
            <button class="btn btn-primary" onclick="createIssue()">Submit Issue</button>
            <button class="btn btn-secondary" onclick="document.getElementById('create-issue-panel').style.display='none'">Cancel</button>
          </div>
        </div>
      </div>`;

    // Initial render
    renderRows();
    updateSortButtons();
  } catch(e) {
    if (e.message !== 'auth')
      document.getElementById('content').innerHTML = '<p class="error">&#10005; ' + escHtml(e.message) + '</p>';
  }
}

// ── Keep sort button active styles in sync ─────────────────────────────────
function updateSortButtons() {
  document.querySelectorAll('.sort-btn').forEach(btn => {
    btn.classList.toggle('sort-active', btn.textContent.trim().toLowerCase().replace(' ', '-') === activeSort ||
      (btn.textContent.trim() === 'Newest' && activeSort === 'newest') ||
      (btn.textContent.trim() === 'Oldest' && activeSort === 'oldest') ||
      (btn.textContent.trim() === 'Most commented' && activeSort === 'most-commented'));
  });
}

function showCreateIssue() {
  document.getElementById('create-issue-panel').style.display = '';
  document.getElementById('issue-title').focus();
}

async function createIssue() {
  const title = document.getElementById('issue-title').value.trim();
  const body  = document.getElementById('issue-body').value.trim();
  if (!title) { alert('Please enter a title'); return; }
  try {
    await apiFetch('/repos/' + repoId + '/issues', {
      method: 'POST',
      body: JSON.stringify({ title, body }),
    });
    location.reload();
  } catch(e) {
    if (e.message !== 'auth') alert('Failed to create issue: ' + e.message);
  }
}

async function suggestIssueBody() {
  const bodyEl = document.getElementById('issue-body');
  const title  = document.getElementById('issue-title').value.trim();
  bodyEl.value = '⏳ Asking Maestro for suggestions…';
  try {
    const ctx = await apiFetch('/repos/' + repoId + '/context/HEAD');
    const suggests = ctx.suggestions || {};
    const missing  = ctx.missingElements || [];
    let suggestion = '';
    if (title && suggests[title]) suggestion = suggests[title];
    else if (missing.length > 0) suggestion = 'Missing musical elements: ' + missing.join(', ') + '.';
    else suggestion = Object.values(suggests).slice(0, 2).join('\n') || 'No AI suggestions available — add more commits to get context.';
    bodyEl.value = suggestion;
  } catch(e) {
    bodyEl.value = '';
    if (e.message !== 'auth') alert('Could not load AI context: ' + e.message);
  }
}

load('open');
{% endraw %}
{% endblock %}
