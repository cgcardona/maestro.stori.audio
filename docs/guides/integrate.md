# Integrate: Frontend, MCP, access

API base URL, auth, Swift/DAW integration, and MCP (Cursor/Claude) in one place. **Full MCP tool list and parameters:** [api.md](../reference/api.md).

---

## API & auth

- **Base URL:** e.g. `https://your-domain.com` (no trailing slash). Use for health, maestro, conversations, assets.
- **Auth:** `Authorization: Bearer <access_token>` on every request **except** `GET /api/v1/health` and **except asset endpoints** (see below). 401 → token missing/invalid/expired; re-auth or refresh.
- **Health:** `GET /api/v1/health` — no auth. Use before authenticated calls.

---

## Single identifier (device UUID)

The app and the backend use **one identifier**: the **device UUID** (generated by the app once per install, e.g. `UUID().uuidString`, stored in UserDefaults).

| Where | How it's sent | Backend use |
|-------|----------------|-------------|
| **Registration** | `POST /api/v1/users/register` body: `{ "user_id": "<device-uuid>" }` | Creates or returns user with `id = device UUID`. No JWT required. |
| **Maestro, MCP, validate-token, users/me, conversations** | `Authorization: Bearer <jwt>` (JWT `sub` = device UUID) | Identifies user from JWT; `sub` must be the same device UUID so budget/usage/conversations match. |
| **Assets** (drum kits, soundfonts, download URLs) | Header `X-Device-ID: <device-uuid>` only (no JWT) | Identifies client by device UUID; rate limited per device. |

**Canonical flow:** (1) App has device UUID. (2) App registers with that UUID. (3) When issuing an access code for that user, use `--user-id <device_uuid>` so the JWT `sub` is the device UUID. (4) App uses that JWT for Maestro/MCP/validate-token/users/me and sends the same UUID as `X-Device-ID` on asset requests. One ID everywhere.

---

## Access codes (JWT)

Tokens are time-limited JWTs (HMAC-SHA256). No DB lookup; no revocation until expiry. Rotate `ACCESS_TOKEN_SECRET` to invalidate all.

**Generate secret:** `openssl rand -hex 32` → set `ACCESS_TOKEN_SECRET` in `.env`.

**Issue a code (from repo root, stack running):**

For the **app flow** (single identifier), the app registers first with its device UUID; then you issue a token with that same UUID so JWT `sub` = device UUID:

```bash
# 1. App has already registered with its device UUID (or you have it from support).
# 2. Issue a token with that UUID (replace with the app's device UUID):
docker compose exec maestro python scripts/generate_access_code.py --user-id <device-uuid> --days 7
```

Share the printed token with the user; they enter it in the app. The app sends it as `Authorization: Bearer <token>` and uses the same device UUID as `X-Device-ID` on asset requests.

**One-off / testing:** To create a new user without an app (e.g. for curl or MCP testing), use `--generate-user-id` and then register that UUID so the user has a budget:

```bash
docker compose exec maestro python scripts/generate_access_code.py --generate-user-id --days 7
# Register the printed user_id:
curl -X POST https://<your-api>/api/v1/users/register -H "Content-Type: application/json" -d '{"user_id": "<user_id from script>"}'
```

**Give the token a budget:** Tokens include a `sub` (user id = device UUID for app flow). Budget is per user in the DB.

1. **App flow:** App registers with its device UUID; you issue token with `--user-id <device_uuid>` so `sub` = device UUID.
2. **One-off:** Use `--generate-user-id`, then `POST /api/v1/users/register` with that `user_id` so they get the default budget.
3. **(Optional)** Set a custom budget (admin token required):
   ```bash
   curl -X POST https://<your-api>/api/v1/users/<user_id>/budget \
     -H "Authorization: Bearer <admin_token>" \
     -H "Content-Type: application/json" \
     -d '{"budget_cents": 1000}'
   ```
   Generate an admin token with `--admin` in the script.

**Backend-issued token → frontend:** The JWT `sub` is the user id (device UUID in the app flow). Budget, usage, and `GET /api/v1/users/me` all follow from the token. The app should use the same device UUID for register and X-Device-ID so one identity is used everywhere.

---

## Muse Hub web UI

Maestro ships a built-in browser UI for navigating remote Muse repos — no
separate frontend required.

### URL structure

| Page | URL |
|------|-----|
| Repo overview (branch selector + commit log) | `GET /musehub/ui/{repo_id}` |
| Commit detail (metadata + artifact browser) | `GET /musehub/ui/{repo_id}/commits/{commit_id}` |
| Pull request list | `GET /musehub/ui/{repo_id}/pulls` |
| Pull request detail (+ Merge button) | `GET /musehub/ui/{repo_id}/pulls/{pr_id}` |
| Issue list | `GET /musehub/ui/{repo_id}/issues` |
| Issue detail (+ Close button) | `GET /musehub/ui/{repo_id}/issues/{number}` |

### Authentication in the browser

The UI routes return HTML shells — no JWT is required to load the page.
JavaScript in each page reads a JWT from `localStorage` (key `musehub_token`) and
passes it as a `Bearer` header when calling the JSON API. If the key is absent or
expired the page shows a password-style input so you can paste in a token.

**One-time setup in the browser:**
1. Obtain a JWT (see [Muse Hub CLI authentication](#muse-hub-cli-authentication) below).
2. Open any `/musehub/ui/` URL in your browser.
3. Paste the JWT into the **"Enter your Maestro JWT"** field and click **Save & Load**.

The token persists in `localStorage` until you click **Sign out** or clear browser storage.

### Artifact browser

The commit detail page lists all binary artifacts (`.webp` piano rolls, `.mid`
MIDI files, `.mp3` recordings) stored in the repo. Artifacts are displayed by type:
- **`.webp` / `.png`** — rendered inline as piano roll preview images
- **`.mp3` / `.ogg` / `.wav`** — embedded `<audio controls>` player
- **All other types** (`.mid`, `.zip`, …) — download link

Artifacts are served from `GET /api/v1/musehub/repos/{repo_id}/objects/{object_id}/content`.
Content-Type is inferred from the file extension; binary content is read from the
Hub's object storage directory (`settings.musehub_objects_dir`).

---

## Muse Hub CLI authentication

All `/musehub/` routes require a valid JWT Bearer token. The Muse CLI reads this token from `.muse/config.toml` automatically — no `--token` flag needed on each command.

**One-time setup:**

1. Obtain a token via `POST /auth/token` (or the existing access-code flow):
   ```bash
   docker compose exec maestro python scripts/generate_access_code.py --user-id <device-uuid> --days 30
   ```

2. Add it to your local `.muse/config.toml`:
   ```toml
   [auth]
   token = "eyJ..."
   ```

3. Add `.muse/config.toml` to `.gitignore` so the token is never committed:
   ```
   .muse/config.toml
   ```

4. All subsequent `muse push`, `muse pull`, and `muse hub` commands will pick up the token automatically. If the token is absent or empty the CLI exits with code `1` and prints:
   ```
   No auth token configured. Add `token = "..."` under `[auth]` in `.muse/config.toml`.
   ```

**Security note:** The token value is never logged. Log lines use `"Bearer ***"` as a placeholder. See [security.md](security.md#muse-hub-cli-token-storage) for full storage guidance.

---

## Muse Hub — Remote Sync Workflow

After authenticating (see above), sync local commits to the shared Hub using
`muse remote add`, `muse push`, and `muse pull`.

### Setup (once per repo)

```bash
# Register the remote Hub URL
muse remote add origin https://story.audio/musehub/repos/<repo-id>

# Verify
muse remote -v
# origin  https://story.audio/musehub/repos/<repo-id>
```

### Clone (starting from scratch)

Use `muse clone` when you are joining a project that already exists on the Hub.
It initialises the local repo, fetches the commit history, and configures
"origin" in one step — no separate `muse init` or `muse remote add` needed.

```bash
# Clone into a directory named after the repo
muse clone https://hub.stori.app/repos/<repo-id>

# Clone into a specific local directory
muse clone https://hub.stori.app/repos/<repo-id> ./my-project

# Shallow clone — only the latest commit
muse clone https://hub.stori.app/repos/<repo-id> --depth 1

# Clone and check out a specific branch
muse clone https://hub.stori.app/repos/<repo-id> --branch feature/guitar

# Download only the keyboard files (saves bandwidth for large projects)
muse clone https://hub.stori.app/repos/<repo-id> --single-track keys

# Fetch commit graph only, skip working-tree population
muse clone https://hub.stori.app/repos/<repo-id> --no-checkout
```

### Push

```bash
# Push all new commits on the current branch to origin
muse push

# Push a specific branch
muse push --branch feature/groove-v2

# Push to a non-default remote
muse push --remote staging
```

### Pull

```bash
# Pull any commits from origin that are not yet local
muse pull

# Pull a specific branch
muse pull --branch main

# After pull, if branches diverged:
# ⚠️  Local branch has diverged from origin/main.
#    Run `muse merge origin/main` to integrate remote changes.
```

### Collaboration pattern

```
Gabriel (Machine A)                Rene (Machine B)
─────────────────────              ─────────────────────
muse commit -m "groove v1"
muse push                          muse clone <hub-url>
                                   muse ask "what changed?"
                                   muse commit -m "variation"
                                   muse push
muse pull
muse merge origin/main
```

For full CLI reference see [muse_vcs.md](../architecture/muse_vcs.md#muse-cli-remote-sync-command-reference).

---

## Frontend (Swift)

**Auth & identity parity:** The app should use the backend's single-identifier architecture (device UUID). Register, get JWT for maestro/MCP, use X-Device-ID only for assets.

- **Assets:** Asset endpoints use **X-Device-ID only** (no JWT). Send header `X-Device-ID: <device-uuid>` (the app’s per-install UUID). List drum kits: `GET /api/v1/assets/drum-kits`. Download URL: `GET /api/v1/assets/drum-kits/{id}/download-url` → response has `url` (presigned S3, use within 30 min) and `expires_at`.
- **CORS:** Backend allows origins in `CORS_ORIGINS` (e.g. `https://your-app-domain.com`, `stori://`). No wildcard in prod.
- **Stage:** `/docs` and `/openapi.json` are off when `DEBUG=false`; use local or debug backend for interactive docs.

---

## MCP (Cursor / Claude)

Stori Maestro is an MCP server. Cursor, Claude Desktop, or any MCP client can list and call tools. Same tool set as the Stori app; DAW tools are forwarded to the Stori instance connected via WebSocket.

**WebSocket (DAW):** Stori connects to `ws://<host>:10001/api/v1/mcp/daw` (with `?token=<jwt>`). When an MCP client calls a DAW tool, Maestro forwards it to that connected DAW.

**Cursor / Claude (stdio):** Run the stdio server via Docker so it shares the stack; for **DAW tools** (e.g. `stori_read_project`, `stori_play`) to work, set `MAESTRO_MCP_URL` and `MCP_TOKEN` so the stdio process proxies those calls to the backend (where the Stori app WebSocket is registered). Without them, DAW tools return "No DAW connected"; generation tools still work.

**Config (one block):** Replace `REPO_ROOT` with the path to the maestro repo and `YOUR_JWT` with a valid access token (do not commit the token). Use `-f` so Compose finds the file. With **Docker exec**, the process runs inside the container and does not see Cursor's `env` block, so pass proxy vars with **`-e`** in the args:

```json
"stori-daw": {
  "command": "docker",
  "args": [
    "compose", "-f", "REPO_ROOT/docker-compose.yml",
    "exec", "-T",
    "-e", "MAESTRO_MCP_URL=http://localhost:10001",
    "-e", "MCP_TOKEN=YOUR_JWT",
    "maestro",
    "python", "-m", "maestro.mcp.stdio_server"
  ],
  "cwd": "REPO_ROOT"
}
```

**HTTP:** `GET /api/v1/mcp/tools` (list), `POST /api/v1/mcp/tools/<name>/call` (call). Auth: Bearer token.

**SSE (alternative to WebSocket):** Obtain a server-issued connection ID with `POST /api/v1/mcp/connection` (Bearer). Then connect to `GET /api/v1/mcp/stream/{connection_id}` for the event stream and post tool results to `POST /api/v1/mcp/response/{connection_id}`. Connection IDs expire after 5 minutes.

Tool list and parameters: see [api.md](../reference/api.md#tools).

---

### MCP MVP: prove it works

You already have: HTTP endpoints (list/call with Bearer), stdio server (`maestro.mcp.stdio_server`), WebSocket for DAW, and server-side generation tools (e.g. `stori_generate_drums`) that run without a connected DAW. To **prove the MCP idea** end-to-end:

**1. Prove “list tools + call one tool” (no DAW)**  
Use the **HTTP** API so you don’t depend on Cursor/Claude or Swift.

- Backend running (e.g. `docker compose up -d`), `.env` with `ACCESS_TOKEN_SECRET` and Orpheus (e.g. `STORPHEUS_BASE_URL`).
- Valid JWT (e.g. `scripts/generate_access_code.py --generate-user-id --days 1`); register the user if you use budget.
- List tools:  
  `curl -s -H "Authorization: Bearer <token>" https://<host>/api/v1/mcp/tools`
- Call a **server-side** tool (no DAW needed):  
  `curl -s -X POST -H "Authorization: Bearer <token>" -H "Content-Type: application/json" -d '{"name":"stori_generate_drums","arguments":{"style":"boom_bap","tempo":90,"bars":4}}' https://<host>/api/v1/mcp/tools/stori_generate_drums/call`
  (Request body: `name` + `arguments`; tool name also in URL path.)

If you get a JSON response with `success: true` and generated notes, MCP “works” for server-side generation.

**2. Prove Cursor (or Claude) sees and uses the server (stdio)**  
So an LLM client can list and call tools.

**2a. Verify the stdio server starts** (from repo root):

- **Option A – Docker** (recommended; uses container env and no local Python deps):  
  `docker compose exec -T maestro python -m maestro.mcp.stdio_server`  
  Pipe two JSON-RPC lines to confirm:  
  `(printf '%s\n' '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{}}' '{"jsonrpc":"2.0","id":2,"method":"tools/list","params":{}}'; sleep 0.3) | docker compose exec -T maestro python -m maestro.mcp.stdio_server 2>/dev/null`  
  You should see two JSON lines on stdout (initialize result + tools list).
- **Option B – Local Python**: from repo root with a venv that has the app and deps (`pip install -e .`):  
  `python -m maestro.mcp.stdio_server`  
  You should see “Stori MCP Server starting…” on stderr.

**2b. Add the MCP server in Cursor**

- Open Cursor settings → MCP (or the config file where MCP servers are listed).
- Use the **Cursor (stdio)** config block from the MCP section above (Docker + `env` for DAW proxy). Replace `REPO_ROOT` with your repo path and `YOUR_JWT` with a valid token. Ensure Docker is running and the stack is up (`docker compose up -d`). For the full config snippet see that section.

  **Docker (recommended):**  
  Use `-f` so Docker Compose finds the file even if Cursor doesn’t set the working directory (avoids “no configuration file provided: not found”):
  ```json
  "stori-daw": {
    "command": "docker",
    "args": [
      "compose", "-f", "REPO_ROOT/docker-compose.yml",
      "exec", "-T", "maestro",
      "python", "-m", "maestro.mcp.stdio_server"
    ],
    "cwd": "REPO_ROOT"
  }
  ```
  Replace `REPO_ROOT` with your repo path. Ensure Docker is running and the stack is up (`docker compose up -d`).

  **Local Python:**
  ```json
  "stori-daw": {
    "command": "python",
    "args": ["-m", "maestro.mcp.stdio_server"],
    "cwd": "REPO_ROOT"
  }
  ```
  Requires a venv (or env) with the app installed and deps (e.g. `pip install -e .`).

- Restart Cursor (or **Developer: Reload Window**) so it starts the server. If you see **"Found 0 tools"** after changing config, do a full window reload (not just resaving `mcp.json`). To verify the server returns tools from the container: run `tools/list` via stdio (see [api.md](../reference/api.md)); from repo root you can pipe `initialize` + `tools/list` JSON lines into `docker compose exec -T maestro python -m maestro.mcp.stdio_server` and check the last line has `"result":{"tools":[...]}` with 41 tools.

**2c. Test in Cursor**

- In a chat, ask: “List Stori DAW tools” or “Call stori_generate_drums with style boom_bap, tempo 90, 4 bars”.
- If Cursor lists the tools and/or returns a result from `stori_generate_drums`, the stdio MCP path works.

**3. (Optional) Prove DAW forwarding**  
Requires the Stori app (Swift) running and connected. If you use **Cursor with stdio**, set `MAESTRO_MCP_URL=http://localhost:10001` and `MCP_TOKEN=<jwt>` in the environment so the stdio server proxies DAW tools to the backend (where the app’s WebSocket is registered).

- Stori app opens a WebSocket to `wss://<host>/api/v1/mcp/daw?token=<jwt>`.
- From Cursor (or HTTP), call a **DAW** tool (e.g. `stori_play`, `stori_read_project`).  
  If the DAW responds (e.g. playback starts, or project state is returned), the full MCP → Maestro → DAW flow is proven.

**Summary**

| What you prove        | Needs DAW? | Needs Cursor/Claude? |
|-----------------------|------------|-----------------------|
| List + call (HTTP)    | No         | No                    |
| Stdio MCP in Cursor   | No (for generation) | Yes          |
| DAW tool (play, read) | Yes        | Optional              |

Start with (1); then (2) if you want to demo inside Cursor; then (3) when the app is ready to connect.

**Next steps after MCP works in Cursor**

1. **Confirm from Cursor** - In chat, list tools and call one (e.g. `stori_generate_drums` or, with a DAW connected, `stori_read_project`).
2. **Wire WebSockets on the front end** – Stori app connects to `wss://<host>/api/v1/mcp/daw?token=<jwt>`, handles `tool_call` messages, runs the action in the DAW, and sends `tool_response` with `request_id` and `result`.
3. **Test track icon/color from Cursor** – With the DAW connected over WebSocket, ask Cursor to change a track’s icon or color. Use `stori_set_track_icon` (e.g. `icon`: `pianokeys`, `guitars`, `music.note`) or `stori_set_track_color` (e.g. `color`: `blue`, `green`). The backend forwards these to the DAW; the app must implement the handlers and respond with `tool_response`.


---

## Agent Context — Starting a Composition Session

The agent context endpoint is the canonical first call an AI agent makes when starting
a composition session. It returns a complete musical briefing in a single HTTP request.

### Usage

```bash
# Standard depth (default — fits in ~8K tokens)
curl -H "Authorization: Bearer $TOKEN" \
  "https://hub.stori.app/api/v1/musehub/repos/<repo-id>/context"

# Brief depth for tight context windows (~2K tokens)
curl -H "Authorization: Bearer $TOKEN" \
  "https://hub.stori.app/api/v1/musehub/repos/<repo-id>/context?depth=brief"

# Target a specific branch
curl -H "Authorization: Bearer $TOKEN" \
  "https://hub.stori.app/api/v1/musehub/repos/<repo-id>/context?ref=main"

# YAML format (human-readable, useful in agent logs)
curl -H "Authorization: Bearer $TOKEN" \
  "https://hub.stori.app/api/v1/musehub/repos/<repo-id>/context?format=yaml"
```

### What agents receive

The response contains seven sections:

| Section | Description | Notes |
|---------|-------------|-------|
| `musicalState` | Key, tempo, time signature, active tracks | Optional fields `null` until Storpheus MIDI integration |
| `history` | Recent commits (newest first) | 3 / 10 / 50 entries at brief / standard / verbose |
| `analysis` | Per-dimension highlights (harmony, groove, etc.) | All `null` at MVP |
| `activePrs` | Open pull requests | Bodies included at `standard` and `verbose` depth |
| `openIssues` | Open issues | Bodies included at `verbose` depth only |
| `suggestions` | Actionable next steps | Heuristic at MVP; LLM-powered in future |

### Depth selection guide

| Goal | Depth | Approximate size |
|------|-------|-----------------|
| Fit in a 2K-token budget (GPT-4o-mini tools) | `brief` | ≤ 2K tokens |
| Full briefing for a new session | `standard` | ≤ 8K tokens |
| Full audit / detailed analysis | `verbose` | Uncapped |

### Python example

```python
import httpx

async def get_context(repo_id: str, token: str, depth: str = "standard") -> dict:
    async with httpx.AsyncClient() as client:
        response = await client.get(
            f"https://hub.stori.app/api/v1/musehub/repos/{repo_id}/context",
            headers={"Authorization": f"Bearer {token}"},
            params={"depth": depth},
        )
        response.raise_for_status()
        return response.json()
```

---

## Embedding MuseHub Compositions on External Sites

MuseHub compositions can be embedded on any website using an `<iframe>`, like SoundCloud or Spotify embeds.

### Embed URL

```
GET /musehub/ui/{repo_id}/embed/{ref}
```

| Segment   | Description                                       |
|-----------|---------------------------------------------------|
| `repo_id` | UUID of the MuseHub repository                    |
| `ref`     | Commit SHA or branch name (e.g. `main`, `abc123`) |

- **No auth required** — publicly accessible for any repo.
- Sets `X-Frame-Options: ALLOWALL` so browsers allow cross-origin framing.

**Example iframe:**

```html
<iframe
  src="https://musehub.stori.app/musehub/ui/aaaabbbb-cccc-dddd-eeee-ffff00001111/embed/main"
  width="560" height="152"
  frameborder="0" allowtransparency="true" allow="autoplay" scrolling="no">
</iframe>
```

### oEmbed Auto-Embedding

MuseHub supports the [oEmbed standard](https://oembed.com/), enabling CMSes
(Wordpress, Ghost, Notion) to auto-embed compositions when a URL is pasted.

```
GET /oembed?url={embed_url}&maxwidth={w}&maxheight={h}
```

| Parameter   | Type   | Default  | Description                                   |
|-------------|--------|----------|-----------------------------------------------|
| `url`       | string | required | The MuseHub embed URL to resolve              |
| `maxwidth`  | int    | 560      | Maximum iframe width in pixels (100 to 1200)  |
| `maxheight` | int    | 152      | Maximum iframe height in pixels (80 to 400)   |
| `format`    | string | `json`   | Response format; only `json` is supported     |

Returns `404` if the URL does not match the embed URL pattern.
Returns `501` if `format=xml` is requested.

### Player UI Elements

| Element                  | Description                                     |
|--------------------------|-------------------------------------------------|
| Play/Pause button        | Toggles audio playback                          |
| Progress bar             | Clickable seek; updates in real-time            |
| Track title              | Filename of first audio object in the commit    |
| Time display             | Current position and total duration             |
| "View on Muse Hub" link  | Opens full repo browser in a new tab            |

Audio is fetched from `/api/v1/musehub/repos/{repo_id}/objects` at load time.
The first `mp3`, `ogg`, `wav`, or `m4a` file found is played.
The widget is responsive and works from 300 px to full viewport width.
