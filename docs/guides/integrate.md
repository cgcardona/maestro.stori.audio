# Integrate: Frontend, MCP, access

API base URL, auth, Swift/DAW integration, and MCP (Cursor/Claude) in one place. **Full MCP tool list and parameters:** [api.md](../reference/api.md).

---

## API & auth

- **Base URL:** e.g. `https://your-domain.com` (no trailing slash). Use for health, maestro, conversations, assets.
- **Auth:** `Authorization: Bearer <access_token>` on every request **except** `GET /api/v1/health` and **except asset endpoints** (see below). 401 → token missing/invalid/expired; re-auth or refresh.
- **Health:** `GET /api/v1/health` — no auth. Use before authenticated calls.

---

## Single identifier (device UUID)

The app and the backend use **one identifier**: the **device UUID** (generated by the app once per install, e.g. `UUID().uuidString`, stored in UserDefaults).

| Where | How it's sent | Backend use |
|-------|----------------|-------------|
| **Registration** | `POST /api/v1/users/register` body: `{ "user_id": "<device-uuid>" }` | Creates or returns user with `id = device UUID`. No JWT required. |
| **Maestro, MCP, validate-token, users/me, conversations** | `Authorization: Bearer <jwt>` (JWT `sub` = device UUID) | Identifies user from JWT; `sub` must be the same device UUID so budget/usage/conversations match. |
| **Assets** (drum kits, soundfonts, download URLs) | Header `X-Device-ID: <device-uuid>` only (no JWT) | Identifies client by device UUID; rate limited per device. |

**Canonical flow:** (1) App has device UUID. (2) App registers with that UUID. (3) When issuing an access code for that user, use `--user-id <device_uuid>` so the JWT `sub` is the device UUID. (4) App uses that JWT for Maestro/MCP/validate-token/users/me and sends the same UUID as `X-Device-ID` on asset requests. One ID everywhere.

---

## Access codes (JWT)

Tokens are time-limited JWTs (HMAC-SHA256). No DB lookup; no revocation until expiry. Rotate `ACCESS_TOKEN_SECRET` to invalidate all.

**Generate secret:** `openssl rand -hex 32` → set `ACCESS_TOKEN_SECRET` in `.env`.

**Issue a code (from repo root, stack running):**

For the **app flow** (single identifier), the app registers first with its device UUID; then you issue a token with that same UUID so JWT `sub` = device UUID:

```bash
# 1. App has already registered with its device UUID (or you have it from support).
# 2. Issue a token with that UUID (replace with the app's device UUID):
docker compose exec maestro python scripts/generate_access_code.py --user-id <device-uuid> --days 7
```

Share the printed token with the user; they enter it in the app. The app sends it as `Authorization: Bearer <token>` and uses the same device UUID as `X-Device-ID` on asset requests.

**One-off / testing:** To create a new user without an app (e.g. for curl or MCP testing), use `--generate-user-id` and then register that UUID so the user has a budget:

```bash
docker compose exec maestro python scripts/generate_access_code.py --generate-user-id --days 7
# Register the printed user_id:
curl -X POST https://<your-api>/api/v1/users/register -H "Content-Type: application/json" -d '{"user_id": "<user_id from script>"}'
```

**Give the token a budget:** Tokens include a `sub` (user id = device UUID for app flow). Budget is per user in the DB.

1. **App flow:** App registers with its device UUID; you issue token with `--user-id <device_uuid>` so `sub` = device UUID.
2. **One-off:** Use `--generate-user-id`, then `POST /api/v1/users/register` with that `user_id` so they get the default budget.
3. **(Optional)** Set a custom budget (admin token required):
   ```bash
   curl -X POST https://<your-api>/api/v1/users/<user_id>/budget \
     -H "Authorization: Bearer <admin_token>" \
     -H "Content-Type: application/json" \
     -d '{"budget_cents": 1000}'
   ```
   Generate an admin token with `--admin` in the script.

**Backend-issued token → frontend:** The JWT `sub` is the user id (device UUID in the app flow). Budget, usage, and `GET /api/v1/users/me` all follow from the token. The app should use the same device UUID for register and X-Device-ID so one identity is used everywhere.

---

## Frontend (Swift)

**Auth & identity parity:** The app should use the backend's single-identifier architecture (device UUID). Register, get JWT for maestro/MCP, use X-Device-ID only for assets.

- **Assets:** Asset endpoints use **X-Device-ID only** (no JWT). Send header `X-Device-ID: <device-uuid>` (the app’s per-install UUID). List drum kits: `GET /api/v1/assets/drum-kits`. Download URL: `GET /api/v1/assets/drum-kits/{id}/download-url` → response has `url` (presigned S3, use within 30 min) and `expires_at`.
- **CORS:** Backend allows origins in `CORS_ORIGINS` (e.g. `https://your-app-domain.com`, `stori://`). No wildcard in prod.
- **Stage:** `/docs` and `/openapi.json` are off when `DEBUG=false`; use local or debug backend for interactive docs.

---

## MCP (Cursor / Claude)

Stori Maestro is an MCP server. Cursor, Claude Desktop, or any MCP client can list and call tools. Same tool set as the Stori app; DAW tools are forwarded to the Stori instance connected via WebSocket.

**WebSocket (DAW):** Stori connects to `ws://<host>:10001/api/v1/mcp/daw` (with `?token=<jwt>`). When an MCP client calls a DAW tool, Maestro forwards it to that connected DAW.

**Cursor / Claude (stdio):** Run the stdio server via Docker so it shares the stack; for **DAW tools** (e.g. `stori_read_project`, `stori_play`) to work, set `MAESTRO_MCP_URL` and `MCP_TOKEN` so the stdio process proxies those calls to the backend (where the Stori app WebSocket is registered). Without them, DAW tools return "No DAW connected"; generation tools still work.

**Config (one block):** Replace `REPO_ROOT` with the path to the maestro repo and `YOUR_JWT` with a valid access token (do not commit the token). Use `-f` so Compose finds the file. With **Docker exec**, the process runs inside the container and does not see Cursor's `env` block, so pass proxy vars with **`-e`** in the args:

```json
"stori-daw": {
  "command": "docker",
  "args": [
    "compose", "-f", "REPO_ROOT/docker-compose.yml",
    "exec", "-T",
    "-e", "MAESTRO_MCP_URL=http://localhost:10001",
    "-e", "MCP_TOKEN=YOUR_JWT",
    "maestro",
    "python", "-m", "maestro.mcp.stdio_server"
  ],
  "cwd": "REPO_ROOT"
}
```

**HTTP:** `GET /api/v1/mcp/tools` (list), `POST /api/v1/mcp/tools/<name>/call` (call). Auth: Bearer token.

**SSE (alternative to WebSocket):** Obtain a server-issued connection ID with `POST /api/v1/mcp/connection` (Bearer). Then connect to `GET /api/v1/mcp/stream/{connection_id}` for the event stream and post tool results to `POST /api/v1/mcp/response/{connection_id}`. Connection IDs expire after 5 minutes.

Tool list and parameters: see [api.md](../reference/api.md#tools).

---

### MCP MVP: prove it works

You already have: HTTP endpoints (list/call with Bearer), stdio server (`maestro.mcp.stdio_server`), WebSocket for DAW, and server-side generation tools (e.g. `stori_generate_drums`) that run without a connected DAW. To **prove the MCP idea** end-to-end:

**1. Prove “list tools + call one tool” (no DAW)**  
Use the **HTTP** API so you don’t depend on Cursor/Claude or Swift.

- Backend running (e.g. `docker compose up -d`), `.env` with `ACCESS_TOKEN_SECRET` and Orpheus (e.g. `STORPHEUS_BASE_URL`).
- Valid JWT (e.g. `scripts/generate_access_code.py --generate-user-id --days 1`); register the user if you use budget.
- List tools:  
  `curl -s -H "Authorization: Bearer <token>" https://<host>/api/v1/mcp/tools`
- Call a **server-side** tool (no DAW needed):  
  `curl -s -X POST -H "Authorization: Bearer <token>" -H "Content-Type: application/json" -d '{"name":"stori_generate_drums","arguments":{"style":"boom_bap","tempo":90,"bars":4}}' https://<host>/api/v1/mcp/tools/stori_generate_drums/call`
  (Request body: `name` + `arguments`; tool name also in URL path.)

If you get a JSON response with `success: true` and generated notes, MCP “works” for server-side generation.

**2. Prove Cursor (or Claude) sees and uses the server (stdio)**  
So an LLM client can list and call tools.

**2a. Verify the stdio server starts** (from repo root):

- **Option A – Docker** (recommended; uses container env and no local Python deps):  
  `docker compose exec -T maestro python -m maestro.mcp.stdio_server`  
  Pipe two JSON-RPC lines to confirm:  
  `(printf '%s\n' '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{}}' '{"jsonrpc":"2.0","id":2,"method":"tools/list","params":{}}'; sleep 0.3) | docker compose exec -T maestro python -m maestro.mcp.stdio_server 2>/dev/null`  
  You should see two JSON lines on stdout (initialize result + tools list).
- **Option B – Local Python**: from repo root with a venv that has the app and deps (`pip install -e .`):  
  `python -m maestro.mcp.stdio_server`  
  You should see “Stori MCP Server starting…” on stderr.

**2b. Add the MCP server in Cursor**

- Open Cursor settings → MCP (or the config file where MCP servers are listed).
- Use the **Cursor (stdio)** config block from the MCP section above (Docker + `env` for DAW proxy). Replace `REPO_ROOT` with your repo path and `YOUR_JWT` with a valid token. Ensure Docker is running and the stack is up (`docker compose up -d`). For the full config snippet see that section.

  **Docker (recommended):**  
  Use `-f` so Docker Compose finds the file even if Cursor doesn’t set the working directory (avoids “no configuration file provided: not found”):
  ```json
  "stori-daw": {
    "command": "docker",
    "args": [
      "compose", "-f", "REPO_ROOT/docker-compose.yml",
      "exec", "-T", "maestro",
      "python", "-m", "maestro.mcp.stdio_server"
    ],
    "cwd": "REPO_ROOT"
  }
  ```
  Replace `REPO_ROOT` with your repo path. Ensure Docker is running and the stack is up (`docker compose up -d`).

  **Local Python:**
  ```json
  "stori-daw": {
    "command": "python",
    "args": ["-m", "maestro.mcp.stdio_server"],
    "cwd": "REPO_ROOT"
  }
  ```
  Requires a venv (or env) with the app installed and deps (e.g. `pip install -e .`).

- Restart Cursor (or **Developer: Reload Window**) so it starts the server. If you see **"Found 0 tools"** after changing config, do a full window reload (not just resaving `mcp.json`). To verify the server returns tools from the container: run `tools/list` via stdio (see [api.md](../reference/api.md)); from repo root you can pipe `initialize` + `tools/list` JSON lines into `docker compose exec -T maestro python -m maestro.mcp.stdio_server` and check the last line has `"result":{"tools":[...]}` with 41 tools.

**2c. Test in Cursor**

- In a chat, ask: “List Stori DAW tools” or “Call stori_generate_drums with style boom_bap, tempo 90, 4 bars”.
- If Cursor lists the tools and/or returns a result from `stori_generate_drums`, the stdio MCP path works.

**3. (Optional) Prove DAW forwarding**  
Requires the Stori app (Swift) running and connected. If you use **Cursor with stdio**, set `MAESTRO_MCP_URL=http://localhost:10001` and `MCP_TOKEN=<jwt>` in the environment so the stdio server proxies DAW tools to the backend (where the app’s WebSocket is registered).

- Stori app opens a WebSocket to `wss://<host>/api/v1/mcp/daw?token=<jwt>`.
- From Cursor (or HTTP), call a **DAW** tool (e.g. `stori_play`, `stori_read_project`).  
  If the DAW responds (e.g. playback starts, or project state is returned), the full MCP → Maestro → DAW flow is proven.

**Summary**

| What you prove        | Needs DAW? | Needs Cursor/Claude? |
|-----------------------|------------|-----------------------|
| List + call (HTTP)    | No         | No                    |
| Stdio MCP in Cursor   | No (for generation) | Yes          |
| DAW tool (play, read) | Yes        | Optional              |

Start with (1); then (2) if you want to demo inside Cursor; then (3) when the app is ready to connect.

**Next steps after MCP works in Cursor**

1. **Confirm from Cursor** – In chat, list tools and call one (e.g. `stori_generate_drums` or, with a DAW connected, `stori_read_project`).
2. **Wire WebSockets on the front end** – Stori app connects to `wss://<host>/api/v1/mcp/daw?token=<jwt>`, handles `tool_call` messages, runs the action in the DAW, and sends `tool_response` with `request_id` and `result`.
3. **Test track icon/color from Cursor** – With the DAW connected over WebSocket, ask Cursor to change a track’s icon or color. Use `stori_set_track_icon` (e.g. `icon`: `pianokeys`, `guitars`, `music.note`) or `stori_set_track_color` (e.g. `color`: `blue`, `green`). The backend forwards these to the DAW; the app must implement the handlers and respond with `tool_response`.
